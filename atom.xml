<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Echo</title>
  <subtitle>Take it.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://realxz.github.io/"/>
  <updated>2017-06-01T10:52:16.000Z</updated>
  <id>http://realxz.github.io/</id>
  
  <author>
    <name>Echo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Volley 源码分析(不包含图片加载)</title>
    <link href="http://realxz.github.io/2017/05/31/Volley%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://realxz.github.io/2017/05/31/Volley 源码分析/</id>
    <published>2017-05-31T14:09:00.000Z</published>
    <updated>2017-06-01T10:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Volley-的使用流程分析"><a href="#1-Volley-的使用流程分析" class="headerlink" title="1. Volley 的使用流程分析"></a>1. Volley 的使用流程分析</h2><blockquote>
<p>官网示例</p>
<ol>
<li>创建一个请求队列 <code>RequestQueue</code>，并启动队列</li>
<li>创建一个请求 <code>Request</code> 添加到请求队列中</li>
</ol>
</blockquote>
<h3 id="1-创建-RequestQueue-对象"><a href="#1-创建-RequestQueue-对象" class="headerlink" title="1. 创建 RequestQueue 对象"></a>1. 创建 RequestQueue 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> TextView mTextView = (TextView) findViewById(R.id.text);</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 实例化一个请求队列</span></div><div class="line">RequestQueue queue = Volley.newRequestQueue(<span class="keyword">this</span>);</div><div class="line">String url =<span class="string">"http://www.google.com"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个期待类型为字符串类型的请求</span></div><div class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</div><div class="line">            <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">        <span class="comment">// Display the first 500 characters of the response string.</span></div><div class="line">        mTextView.setText(<span class="string">"Response is: "</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">        mTextView.setText(<span class="string">"That didn't work!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 将请求添加到请求队列中</span></div><div class="line">queue.add(stringRequest);</div></pre></td></tr></table></figure>
<p>上面代码片段的第5行，我们调用 <code>Volley.newRequestQueue(this)</code> 来创建一个请求队列。<code>Volley</code> 中提供了两种创建请求队列的方法，<code>newRequestQueue(Context context,HttpStack stack)</code> 和 <code>newRequestQueue(Context context)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"><span class="comment">//  在此方法内部会调用另一个 newRequestQueue 方法，第二个参数为 null 代表使用默认的 HttpStack 实现</span></div><div class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</div><div class="line">    <span class="comment">// 缓存文件目录 data/data/packagename/cache/volley</span></div><div class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line"></div><div class="line">    String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String packageName = context.getPackageName();</div><div class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">        userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">            stack = <span class="keyword">new</span> HurlStack();<span class="comment">//基于HttpClient</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//基于HttpUrlConnection</span></div><div class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//利用HttpStack创建一个Network对象</span></div><div class="line">    Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line"></div><div class="line">    <span class="comment">//创建一个RequestQueue对象，在构造函数中传入缓存对象，网络对象</span></div><div class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">    <span class="comment">//启动队列</span></div><div class="line">    queue.start();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>在上面代码片段中的第2行可以看见，<code>Volley</code> 调用 <code>getCacheDir()</code> 方法来获取缓存目录，<code>Volley</code> 中的缓存文件会存储在 <strong>/data/data/packagename/cache</strong> 目录下面，并不是存储在 SD 卡中的。</p>
<p>从12~18的代码可以看见，<strong>Volley</strong> 当中有对 <code>HttpStack</code> 的默认实现，<code>HttpStack</code> 是真正用来执行请求的接口 ，根据版本号的不同，实例化不同的对象，在  <strong>Android2.3</strong> 版本之前采用基于 <strong>HttpClient</strong> 实现的 <strong>HttpClientStack</strong> 对象，不然则采用基于 <strong>HttpUrlConnection</strong> 实现的 <strong>HUrlStack</strong>。</p>
<p>之后我们通过 <code>HttpStack</code> 构建了一个 <code>Network</code> 对象，它会调用 <code>HttpStack#performRequest()</code> 方法来执行请求，并且将请求的结果转化成 <code>NetworkResponse</code> 对象，<strong>NetworkResponse</strong> 类封装了响应的<strong>响应码</strong>，<strong>响应体</strong>，<strong>响应头</strong>等数据。</p>
<p>接着我们会将之前构建的缓存目录以及网络对象传入 <code>RequestQueue(Cache cache, Network network)</code> 的构造函数中，构造一个 <strong>RequestQueue</strong> 对象，然后调用队列的 <code>start()</code>方法来启动队列，其实就是启动队列中的两种线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//启动队列中所有的调度线程.</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    stop();  <span class="comment">// 确保停止所有当前正在运行的调度线程</span></div><div class="line">    <span class="comment">// 创建缓存调度线程，并启动它，用来处理缓存队列中的请求</span></div><div class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue,mNetworkQueue,mCache,mDelivery);</div><div class="line">    mCacheDispatcher.start();</div><div class="line"></div><div class="line">    <span class="comment">// 创建一组网络调度线程，并启动它们，用来处理网络队列中的请求，默认线程数量为4，也可以通过RequestQueue的构造函数指定线程数量。</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue,mNetwork,mCache, mDelivery);</div><div class="line">        mDispatchers[i] = networkDispatcher;</div><div class="line">        networkDispatcher.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <strong>start()</strong> 方法中，主要是启动了两种线程分别是 <code>CacheDispatcher</code> 和 <code>NetworkDispatcher</code>，它们都是线程类，顾名思义 <strong>CacheDispatcher</strong> 线程会处理缓存队列中请求，<strong>NetworkDispatcher</strong> 处理网络队列中的请求，由此可见在我们调用 <strong>Volley</strong> 的公开方法创建请求队列的时候，其实就是开启了两种线程在等待着处理我们添加的请求。</p>
<h3 id="2-添加请求-add-Request"><a href="#2-添加请求-add-Request" class="headerlink" title="2. 添加请求 add(Request)"></a>2. 添加请求 add(Request)</h3><p>之前我们已经创建了 RequestQueue 对象，现在我们只需要构建一个 <strong>Request</strong> 对象，并将它加入到请求队列中即可。下面我们来看看 <code>add(Request&lt;T&gt; request)</code> 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将请求加入到当前请求队列当中，毋庸置疑的我们需要将所有的请求集合在一个队列中，方便我们做统一操作，例如：取消单个请求或者取消具有相同标记的请求...</span></div><div class="line">    request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">        mCurrentRequests.add(request);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 给请求设置顺序.</span></div><div class="line">    request.setSequence(getSequenceNumber());</div><div class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 如果请求是不能够被缓存的，直接将该请求加入网络队列中.</span></div><div class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">        mNetworkQueue.add(request);</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果有相同的请求正在被处理，就将请求加入对应请求的等待队列中去.等到相同的正在执行的请求处理完毕的时候会调用 finish()方法，然后将这些等待队列中的请求全部加入缓存队列中去，让缓存线程来处理</span></div><div class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">        String cacheKey = request.getCacheKey();</div><div class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            <span class="comment">// 有相同请求在处理，加入等待队列.</span></div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            stagedRequests.add(request);</div><div class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);&#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 向mWaitingRequests中插入一个当前请求的空队列，表明当前请求正在被处理</span></div><div class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">            mCacheQueue.add(request);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<center><img src="http://static.zybuluo.com/xiezhen/eg4o9tcjsieaaom3yjro7kcr/add.png" alt="add.png-53.6kB"></center><br><center><strong>RequestQueue#add(Request)</strong> 方法的调用流程</center>

<p>###3. 处理请求 Cache/NetworkDispatcher</p>
<p>请求被加入缓存请求队列或者是网络请求队列，在后台我们的缓存处理线程，网络处理线程，一直在运行着等待着请求的到来。我们先来看看 <strong>CacheDispatcher</strong> 线程是如何处理的:</p>
<p><strong>CacheDispatcher</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(</span></span></div><div class="line">    BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class="line">    Cache cache, ResponseDelivery delivery) &#123;</div><div class="line">    mCacheQueue = cacheQueue;</div><div class="line">    mNetworkQueue = networkQueue;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 <strong>CacheDispatcher</strong> 的构造函数，可以看见该对象内部持有<strong>缓存队列</strong>，<strong>网络队列</strong>，<strong>缓存对象</strong>，<strong>响应投递对象</strong>的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"></div><div class="line">    <span class="comment">// 初始化缓存，将缓存目录下的所有缓存文件的摘要信息加载到内存中.</span></div><div class="line">    mCache.initialize();</div><div class="line"></div><div class="line">    <span class="comment">//无线循环，意味着线程启动之后会一直运行</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 从缓存队列中取出一个请求，如果没有请求则一直等待</span></div><div class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 如果当前请求已经取消，那就停止处理它</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 尝试取出缓存实体对象</span></div><div class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                <span class="comment">// 没有缓存，将当前请求加入网络请求队列，让NetworkDispatcher进行处理.</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 如果缓存实体过期，任然将当前请求加入网络请求队列，让NetworkDispatcher进行处理.</span></div><div class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">                mNetworkQueue.put(request);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 将缓存实体解析成NetworkResponse对象.</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">            <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                <span class="comment">// 缓存依旧新鲜，投递响应.</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//缓存已经不新鲜了，我们可以进行响应投递，然后将请求加入网络队列中去，进行新鲜度验证，如果响应码为 304，代表缓存新鲜可以继续使用，不用刷新响应结果</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line"></div><div class="line">                <span class="comment">// 标记当前响应为中间响应，如果经过服务器验证缓存不新鲜了，那么随后将有第二条响应到来.这意味着当前请求并没有完成，只是暂时显示缓存的数据，等到服务器验证缓存的新鲜度之后才会将请求标记为完成</span></div><div class="line">                response.intermediate = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 将响应投递给用户，然后加入网络请求队列中去.</span></div><div class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            mNetworkQueue.put(request);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            <span class="comment">// Not much we can do about this.</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码的注释中基本上可以理清 CacheDispatcher 的工作流程，下面附上流程图<br><img src="http://static.zybuluo.com/xiezhen/azn7u8x7sh22q1dn8zq2oewq/%E7%BC%93%E5%AD%98run%E6%96%B9%E6%B3%95%20.png" alt="缓存run方法 .png-95.6kB"></p>
<center><strong>CacheDispatcher#run() 方法内部流程</strong></center>

<p><strong>NetworkDispatcher</strong><br>在 CacheDispatcher 当中我们会把一些不符合条件的请求加入网络请求队列中，下面我们来看看在 <strong>NetworkDispatcher</strong> 的 <strong>run()</strong> 方法中是怎么来处理这些请求的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span></span></div><div class="line">    Network network, Cache cache,ResponseDelivery delivery) &#123;</div><div class="line">    mQueue = queue;</div><div class="line">    mNetwork = network;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是 <strong>NetworkDispatcher</strong> 的构造函数，可以看见该对象内部持有<strong>网络队列</strong>，<strong>缓存对象</strong>，<strong>响应投递对象</strong>,<strong>Network对象</strong>的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">        Request&lt;?&gt; request;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 从网络队列中取出一个请求，没有请求则一直等待.</span></div><div class="line">            request = mQueue.take();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 如果请求被取消的话，就结束当前请求，不再执行</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            addTrafficStatsTag(request);</div><div class="line"></div><div class="line">            <span class="comment">// 执行网络请求.</span></div><div class="line">            NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">            request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line">            <span class="comment">// 如果响应码为304，并且我们已经传递了一次响应,不需要再传递一次验证的响应，意味着本次请求处理完成。也就是说该请求的缓存是新鲜的，我们直接使用就可以了。</span></div><div class="line">            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 在工作线程中想响应数据解析成我们需要的Response对象，之所以在工作线程进行数据解析，是为了避免一些耗时操作造成主线程的卡顿.</span></div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">            request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line">            <span class="comment">// 如果允许，则将响应数据写入缓存，这里的缓存是需要服务器支持的，这点我们接下来再说</span></div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></div><div class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 传递响应数据.</span></div><div class="line">            request.markDelivered();</div><div class="line">            mDelivery.postResponse(request, response);</div><div class="line">        &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">            parseAndDeliverNetworkError(request, volleyError);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">            VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</div><div class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">            mDelivery.postError(request, volleyError);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码当中的第29行，我们调用 <strong>Network</strong> 对象的 <code>performRequest(Request&lt;?&gt; request)</code> 方法来执行网络请求，并且返回我们需要的 <strong>NetworkResponse</strong> 对象。如果是304响应，并且我们已经传递过一次响应，就不需要在传递新的解析数据，不然我们将数据解析成 Reponse 对象，并传递给主线程进行回到处理，如果该请求允许被缓存，就将该请求的结果写入缓存中去，这就是 Networkdispatcher 的工作流程。以下是 NetworkDispatcher 的流程图:</p>
<center><img src="http://static.zybuluo.com/xiezhen/ndyibftufjge6wxj6hltrxr0/%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8Brun%E6%96%B9%E6%B3%95.png" alt="网络处理线程run方法.png-73.9kB"></center><br><center><strong>NetworkDispatcher的run() 方法</strong></center>

<h3 id="4-执行请求-performRequest"><a href="#4-执行请求-performRequest" class="headerlink" title="4. 执行请求 performRequest"></a>4. 执行请求 performRequest</h3><p>在上面 <strong>NetworkDispatcher</strong> 的代码中第29行，会通过 <code>Network</code> 的 <code>performRequest</code> 方法来进行网络请求:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 执行指定的请求.</div><div class="line">    * <span class="doctag">@param</span> request 被处理的请求</div><div class="line">    * <span class="doctag">@return</span> 一个 NetworkResponse 对象，包含响应的数据，头部以及响应码等数据</div><div class="line">    * <span class="doctag">@throws</span> VolleyError on errors</div><div class="line">    */</div><div class="line">    <span class="function">NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Network 是一个接口，它的内部只有这一个方法，在 Volley 中我们最终调用的是它的实现类，BasicNetwork 的 performRequest() 方法，方法如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();<span class="comment">//请求开始的时间</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</div><div class="line">        Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 收集头部</span></div><div class="line">            Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">            <span class="comment">//对于addCacheHeaders这个方法，我们也会在缓存的部分进行介绍</span></div><div class="line">            addCacheHeaders(headers, request.getCacheEntry());<span class="comment">//附加请求头部,用来验证缓存数据？</span></div><div class="line">            httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">            StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">            <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</div><div class="line"></div><div class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">            <span class="comment">// 验证缓存的新鲜度.</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">                <span class="comment">//请求的资源没有修改，意思可以使用缓存中的数据</span></div><div class="line">                Cache.Entry entry = request.getCacheEntry();</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</div><div class="line">                    responseHeaders, <span class="keyword">true</span>,SystemClock.elapsedRealtime() -requestStart);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// A HTTP 304 response does not have all header fields. We</span></div><div class="line">                <span class="comment">// have to use the header fields from the cache entry plus</span></div><div class="line">                <span class="comment">// the new ones from the response.</span></div><div class="line">                <span class="comment">// http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</span></div><div class="line">                entry.responseHeaders.putAll(responseHeaders);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                            entry.responseHeaders, <span class="keyword">true</span>,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></div><div class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</div><div class="line">                responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Add 0 byte response as a way of honestly representing a</span></div><div class="line">                <span class="comment">// no-content request.</span></div><div class="line">                responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// if the request is slow, log it. 请求持续时间</span></div><div class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">            logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//一条真正的网络响应</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,SystemClock.elapsedRealtime() - requestStart);</div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            <span class="comment">//......这部分代码是用来进行请求重试的，我们随后在做解析</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面代码的第12行，又会调用 <code>HttpStack</code> 对象的 <code>performRequest()</code> 方法去执行网络请求，在 <strong>HttpStack</strong> 中才真正进行网络请求，HttpStack 对象在我们一开始调用 Volley.newRequestQueue() 的方法时候初始化的，默认情况下，如果系统版本在 Android2.3 之前就会创建 HttpClientStack，之后就会创建 HUrlStack 对象，同样我们也可以实现自己的 HttpStack对象，通过 Volley 的重载方法 newRequestQueue(Context,HttpStack) 将我们自定义的 HttpStack 传入即可。</p>
<p>在代码的18行，我们会进行新鲜度验证，如果是304响应那么我们会直接利用缓存实体的数据。之后会将响应的数据组装成一个 NetworkResponse 对象返回。<br>在回到之前 <strong>NetworkDispatcher</strong> 的代码中，当我们获得这个 NetworkResponse 对象之后，如果是304响应那我们的请求处理结束，不然的话就会调用 <code>Request#parseNetworkResponse(NetworkResponse)</code> 方法将 NetworkResponse 对象解析成我们需要的 Response 对象，这是一个抽象方法，由子类具体实现来解析成期望的响应类型，此方法在工作线程调用。如果该请求可以被缓存，就会将响应实体写入缓存，标记请求被投递，然后调用 <code>ResponseDelivery</code> 对象的 <code>postResponse()</code> 方法来将解析的结果投递到主线程中，然后进行回调处理。</p>
<h3 id="5-响应传递、回调-postResponse"><a href="#5-响应传递、回调-postResponse" class="headerlink" title="5.响应传递、回调 postResponse"></a>5.响应传递、回调 postResponse</h3><p>响应结果投递接口，主要负责将响应的结果/错误，投递到主线程中，供回调函数处理:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseDelivery</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传递从网络或者缓存中解析的Response对象.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传递从网络或者缓存中解析的Response对象.提供一个Runnable对象，会在传递之后执行</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传递给定请求的Error</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的内部实现类为 <code>ExecutorDelivery</code>，让我们来看看 <strong>ExecutorDelivery</strong> 中的具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">        mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">                handler.post(command);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们会在 postResponse 方法中调用 mResponsePoster 对象的 execute 方法，紧接着通过 handler 对象发送一个消息，这个消息是 <code>ResponseDeliveryRunnable</code> 对象，它是 Runnable 的实现类，并且这个 Runnable 对象会在主线程被执行，为什么呢？这是因为 handler 是在 ExecutorDelivery 初始化的时候作为参数传递出来的，我们可以看一下该构造函数调用的时机:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</div><div class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看见我们使用主线的 Looper 在构建一个 Handler对象，所以由该 Handler 对象发送的消息，都会在主线程被执行，不熟悉 Handler 机制的可以看下这篇文章 <a href="http://blog.csdn.net/xiezhenaini/article/details/49644853" target="_blank" rel="external">Android消息机制</a>。</p>
<p>接着我们看看这个 <strong>ResponseDeliveryRunnable</strong> 类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//......省略</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// If this request has canceled, finish it and don't deliver.</span></div><div class="line">        <span class="comment">/** 如果请求已经取消的话，就不用在投递了*/</span></div><div class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Deliver a normal response or error, depending.</span></div><div class="line">        <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">            mRequest.deliverResponse(mResponse.result);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mRequest.deliverError(mResponse.error);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class="line">        <span class="comment">// and the request can be finished.</span></div><div class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mRequest.finish(<span class="string">"done"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></div><div class="line">        <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                mRunnable.run();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个 Runnable 会在主线程执行，然后将响应结果传递给请求的回调函数。在代码中的15，17行就是我们的回调函数，每一个请求的响应结果，不论是成功或者是失败，都会传递到这两个方法中，第15行的 <code>deliverResponse</code> 方法也是一个抽象方法，由子类实现，参照 Volley 提供的 StringRequest 可以看见，在这个方法中，我们最终将期望的对象传递给了 <code>Response</code> 中的 <code>onResponse()</code> 方法中，可以看 <strong>创建 RequestQueue 对象</strong> 这一段落的第一段代码中的12行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</div><div class="line">            <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">        <span class="comment">// Display the first 500 characters of the response string.</span></div><div class="line">        mTextView.setText(<span class="string">"Response is: "</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">        mTextView.setText(<span class="string">"That didn't work!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>请求的结果最终就会被传递这 <code>onResponse</code>,<code>onErrorResponse</code> 中。在这里贴一张 Volley 内部的 Response 转换流程图:</p>
<center><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/response-process-flow-chart.png" alt="Response 处理流程图"></center><br><center>图片取自<a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">codeKK Volley 源码分析</a></center><br>### 6.请求完成 Request#finish(String)<br>在执行完我们的回调函数之后，会调用 Request 中的 finish() 方法标记请求完成，然后会将我们的请求从请求队列中移除,以下代码展示了两处调用 finish() 的地方:<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">    mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    mRequest.finish(<span class="string">"done"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>他们的区别是，第一段代码的 Response 是从网络返回的数据，而第二段代码是代表我们之前传递了需要验证缓存新鲜度的缓存实体，经验证后缓存新鲜，标记请求完成，大家可以查看一下 Response 的 intermediate 属性被赋值的时机就明白了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Request中的finish()会调用 RequestQueue中的finish()方法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</div><div class="line">         mRequestQueue.finish(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// RequestQueue#finish(Request)</span></div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">//从当前的请求队列中移除该请求</span></div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">        mCurrentRequests.remove(request);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用该请求设置的回调函数</span></div><div class="line">    <span class="keyword">synchronized</span> (mFinishedListeners) &#123;</div><div class="line">        <span class="keyword">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class="line">        listener.onRequestFinished(request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                            waitingRequests.size(), cacheKey);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// Process all queued up requests. They won't be considered as in flight, but</span></div><div class="line">                <span class="comment">// that's not a problem as the cache has been primed by 'request'.</span></div><div class="line">                mCacheQueue.addAll(waitingRequests);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>在移除已经完成的请求之后，如果该请求是可以缓存的，并且存在着等待该请求的等待队列，就将队列中的所有请求加入缓存队列（mCacheQueue) 中去，让缓存线程接着处理。<br>### 7.补充一点—取消请求<br><br> - 可以调用 Request 的 cancel() 方法来标记请求取消，这样我们的回调函数永远不会被调用<br> - 可以调用 RequstQueue 的 cancelAll(Object) 的方法来批量取消被打上 Object 标记的请求<br> - 可以调用 RequstQueue 的 cancelAll(RequestFilter) 的方法，按照自定义的过滤方法来取消符合过滤条件的请求<br><br>###8. 抽象的处理流程图<br><center><img src="http://static.zybuluo.com/xiezhen/28yjzliwl05211ach572puow/%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="抽象的流程图.png-43.3kB"></center>

<p>通过 CacheDispatcher 和 NetworkDispatcher 两种线程不断的从 RequestQueue 中取出请求来处理，然后将获取的数据在子线程解析成我们需要的结果，通过 ResponseDelivery 的 postResponse 方法将结果投递到主线程中去，触发回调。</p>
<h2 id="2-请求缓存和重试机制"><a href="#2-请求缓存和重试机制" class="headerlink" title="2.请求缓存和重试机制"></a>2.请求缓存和重试机制</h2><p>再此之前我们先看一下 <code>Request</code> 类中的一些重要属性和方法:<br><strong>Request<t></t></strong><br>所有请求的抽象类，T 类型代表请求期望的类型，也是响应最终被解析成的类型。支持 <code>Get</code>,<code>Post</code>,<code>Put</code>,<code>Delete</code>,<code>Options</code>,<code>Trace</code>,<code>Head</code>,<code>Patch</code> 共8种请求，提供 <code>Low</code>,<code>Normal</code>,<code>Hight</code>,<code>Imediate</code> 4种优先级。下面会挑出一些比较重要的字段和方法进行讲解:</p>
<ul>
<li><strong>mShouldCache</strong>，用于标识请求是否允许缓存，缓存需要客户端和服务器的支持，这个字段仅仅代表客户端是否支持缓存</li>
<li><strong>mShouldRetryServerErrors</strong>，默认值为 false，代表在服务器返回响应码在 500~599的范围内的话(服务器错误)，不进行请求重试</li>
<li><strong>mCacheEntry</strong>，该请求的缓存实体，在 CacheDispatcher 处理 CacheQueue 中请求的时候，会判断该请求之前是否有缓存存在，如果存在的话将缓存实体赋值给该字段。用于在服务器返回 304 响应的时候构建 <strong>NetworkResponse</strong> 对象</li>
<li><strong>mResponseDelivered</strong>，代表该请求的响应结果已经被投递到主线程，只有在响应被传递给主线程的时候标记为 true，它的作用同样是用来验证缓存一致性</li>
<li><strong>abstract protected Response<t> parseNetworkResponse(NetworkResponse response)</t></strong>;抽象方法，将请求返回的结果解析成请求期望的类型，具体的解析方式需要子类实现</li>
<li><p><strong>abstract protected void deliverResponse(T response);</strong>抽象方法，也同样需要子类自行实现，将解析后的结果传递给请求的回调函数<br>之前我们有提到过要实现请求缓存需要客户端和服务器端共同的支持才行。</p>
<h3 id="1-请求缓存"><a href="#1-请求缓存" class="headerlink" title="1.请求缓存"></a>1.请求缓存</h3><p>之前我们说过，缓存机制是需要客户端和服务器端共同支持的。从客户端的角度来说：需要实现 Http 缓存相关的语义；从服务器的角度来说：需要允许请求的资源被缓存；我们先来看一些有关于 Http 请求头和响应头的概念:</p>
<h4 id="HTTP-响应头"><a href="#HTTP-响应头" class="headerlink" title="HTTP 响应头"></a><strong>HTTP 响应头</strong></h4><p><strong>Cache-Control</strong>:指明当前资源的有效期，用来控制从缓存中取数据，还是需要将请求发送到服务器进行验证，重新取回数据,该头部有以下几个值：</p>
</li>
<li><p>no-cache:使用缓存前必须先向服务器确认其有效性</p>
</li>
<li>no-store:不缓存响应的任何内容，相同的请求都会发送给服务器</li>
<li>max-age:缓存有效性的最长时间</li>
<li>must-revalidate:可缓存，但是使用的时候必需向源服务器验证</li>
<li>proxy-revalidate:要求中间缓存服务器对缓存的有效性进行确认</li>
<li>stale-while-revalidate：在这段时间内，允许先使用缓存，但需要向服务器验证缓存的有效性</li>
</ul>
<p><strong>Expires</strong>:资源失效的日期，如果和 max-age 同时存在，以 max-age 时间为准<br><strong>ETag</strong>:可将资源以字符串形式做唯一性标识的方式，服务器会为每份资源分配对应的 Etag 值<br><strong>Last-Modified</strong>:资源最终被修改的时间</p>
<h4 id="HTTP-请求头"><a href="#HTTP-请求头" class="headerlink" title="HTTP 请求头"></a><strong>HTTP 请求头</strong></h4><p><strong>If-None-Match</strong>：如果上一次响应的的响应头部中带有 ETag 响应头，再次请求的时候会将 ETag 的值作为 If-None-Match 请求头的值，当 If-None-Match 的值与请求资源的 Etag 不一致时，服务器会处理该请求，该字段用来获取最新的资源<br><strong>If-Modified-Since</strong>：如果上一次响应的响应头部中带有 Last-Modified 响应头，那么再次请求的时候会将 Last-Modified 的值作为 If-Modified-Since 请求头的值，在If-Modified-Since 字段指定的之后，资源发生了更新，服务器会接受该请求，否则返回 304 响应</p>
<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>Cache接口中的内部类，代表着缓存实体</p>
<ul>
<li><strong>data</strong>，这是一个字节数组，其实也就是我们响应的 Content 部分</li>
<li><strong>etag</strong>，用来验证缓存一致性的标记</li>
<li><strong>serverDate</strong>，数据从服务器返回的时间</li>
<li><strong>lastModified</strong>，访问的服务器资源上次被修改的时间</li>
<li><strong>ttl</strong>，数据的过期时间，在(softTtl-ttl)这段时间内我们可以使用缓存，但是必须向服务器验证缓存的有效性</li>
<li><strong>softTtl</strong>，数据的新鲜时间，缓存再次之前一直有效</li>
<li><strong>responseHeaders</strong>，响应头部</li>
<li><strong>boolean isExpired()</strong>，判断是否过期，ttl代表的时间小于当前时间就意味着过期了</li>
<li><strong>boolean refreshNeeded()</strong>，顾名思义，当softTtl代表的时间小于当前时间，就代表数据不新鲜了，需要刷新数据</li>
</ul>
<p>下面我们来看看 Volley 中是怎么利用这些头部信息来对响应结果进行缓存处理的：<br>在 NetworkDispatcher 的 run() 方法中有这样一样代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">    request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想要缓存响应结果需要满足两个条件，第一条该请求允许缓存，我们创建的每一条请求都是默认支持缓存的；第二条就是响应对象中的缓存实体不为空。那么我们需要看一下缓存实体是在什么时候被创建的，在执行上述的 if 语句判断之前会执行这么一句代码 <code>Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</code> 通过parseNetworkResponse 方法将 NetworkResponse 对象转化为 Response 对象，<strong>parseNetworkResponse</strong> 方法是一个抽象方法，我们看一下 StringRequest 中是如何重写该方法的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</div><div class="line">    String parsed;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</div><div class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">        parsed = <span class="keyword">new</span> String(response.data);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码的最后一行，我们会发现 Response 中的 cacheEntry 字段的值来自于 <code>HttpHeaderParser.parseCacheHeaders(response)</code>方法的返回值，下面我们来看看该方法的内部实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">    <span class="comment">//提取响应头部信息</span></div><div class="line">    Map&lt;String, String&gt; headers = response.headers;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> serverDate = <span class="number">0</span>;<span class="comment">//资源返回时间</span></div><div class="line">    <span class="keyword">long</span> lastModified = <span class="number">0</span>;<span class="comment">//资源上一次被修改的时间</span></div><div class="line">    <span class="keyword">long</span> serverExpires = <span class="number">0</span>;<span class="comment">//资源的有效时间，以maxAge为主</span></div><div class="line">    <span class="keyword">long</span> softExpire = <span class="number">0</span>;<span class="comment">//资源的新鲜时间，如果在该时间内，发起相同的请求，那么可以允许使用缓存的信息，不需要将请求发送给服务器。</span></div><div class="line">    <span class="keyword">long</span> finalExpire = <span class="number">0</span>;<span class="comment">//缓存过期时间，在该时间之后的请求，都将发送给服务器，无法使用缓存。</span></div><div class="line">    <span class="keyword">long</span> maxAge = <span class="number">0</span>;<span class="comment">//资源的有效时间，</span></div><div class="line">    <span class="comment">//在 staleWhileRevalidate 时间内，我们可以先用缓存数据展示给用户，在向服务器验证缓存的有效性</span></div><div class="line">    <span class="keyword">long</span> staleWhileRevalidate = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> hasCacheControl = <span class="keyword">false</span>;<span class="comment">//代表是否有 Cache-Control 头部</span></div><div class="line">    <span class="keyword">boolean</span> mustRevalidate = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    String serverEtag = <span class="keyword">null</span>;<span class="comment">//资源在服务器中的标识</span></div><div class="line">    String headerValue;</div><div class="line"></div><div class="line">    headerValue = headers.get(<span class="string">"Date"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        serverDate = parseDateAsEpoch(headerValue);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取 Cache-Contral 头部的相关信息</span></div><div class="line">    headerValue = headers.get(<span class="string">"Cache-Control"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        hasCacheControl = <span class="keyword">true</span>;</div><div class="line">        String[] tokens = headerValue.split(<span class="string">","</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</div><div class="line">            String token = tokens[i].trim();</div><div class="line">            <span class="keyword">if</span> (token.equals(<span class="string">"no-cache"</span>) || token.equals(<span class="string">"no-store"</span>)) &#123;</div><div class="line">            <span class="comment">//如果出现了 no-cache,no-store指令，代表服务器不允许缓存响应，返回的 entry 对象为空</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"max-age="</span>)) &#123;</div><div class="line">            <span class="comment">//如果出现了 max-age指令，那么服务器允许缓存该响应，并且给出响应的过期时间</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    maxAge = Long.parseLong(token.substring(<span class="number">8</span>));</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"stale-while-revalidate="</span>)) &#123;</div><div class="line">            <span class="comment">//这段时间处于新鲜时间和过期时间之间，在这段时间内发起的请求，都可以利用之前的缓存信息，但是需要将请求发送给服务器做验证，如果是304 响应，则请求结束，不然将重新传递响应结果。</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    staleWhileRevalidate = Long.parseLong(token.substring(<span class="number">23</span>));</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"must-revalidate"</span>) || token.equals(<span class="string">"proxy-revalidate"</span>)) &#123;</div><div class="line">            <span class="comment">//代表不区分新鲜时间与过期时间，到了max-age指定的时间之后，请求都将发送给服务器用来验证缓存的有效性。</span></div><div class="line">                mustRevalidate = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    headerValue = headers.get(<span class="string">"Expires"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        serverExpires = parseDateAsEpoch(headerValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    headerValue = headers.get(<span class="string">"Last-Modified"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        lastModified = parseDateAsEpoch(headerValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    serverEtag = headers.get(<span class="string">"ETag"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 在 Cache-Control 和 Expires 头部都存在的情况下，以Cache-Control为准</span></div><div class="line">    <span class="keyword">if</span> (hasCacheControl) &#123;</div><div class="line">        softExpire = now + maxAge * <span class="number">1000</span>;</div><div class="line">        finalExpire = mustRevalidate</div><div class="line">                    ? softExpire</div><div class="line">                    : softExpire + staleWhileRevalidate * <span class="number">1000</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</div><div class="line">    <span class="comment">// Default semantic for Expire header in HTTP specification is softExpire.</span></div><div class="line">        softExpire = now + (serverExpires - serverDate);</div><div class="line">        finalExpire = softExpire;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Cache.Entry entry = <span class="keyword">new</span> Cache.Entry();</div><div class="line">    entry.data = response.data;</div><div class="line">    entry.etag = serverEtag;</div><div class="line">    entry.softTtl = softExpire;</div><div class="line">    entry.ttl = finalExpire;</div><div class="line">    entry.serverDate = serverDate;</div><div class="line">    entry.lastModified = lastModified;</div><div class="line">    entry.responseHeaders = headers;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个静态工具方法，用于提取响应头部的信息，来构建一个 Cache.Entry 类型的缓存对象，针对该方法的分析都已经写在注释当中。现在我们已经了解了将响应转化为缓存的部分，下面我们来看看，Volley 是如何使用缓存的,在上面我们介绍 <strong>CacheDispatcher</strong> 工作流程的时候已经大致看过了处理缓存请求的过程，下面我再针对缓存的部分具体分析一下，下面是 CacheDispatcher run() 方法的部分代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line"><span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">    mNetworkQueue.put(request);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">    request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">    request.setCacheEntry(entry);</div><div class="line">    mNetworkQueue.put(request);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line">Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">            <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line"><span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">    mDelivery.postResponse(request, response);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    request.setCacheEntry(entry);</div><div class="line">    response.intermediate = <span class="keyword">true</span>;</div><div class="line">    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            mNetworkQueue.put(request);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先从缓存中取出缓存实体，然后通过 <code>isExpired()</code> 判断该缓存有无过期，内部是通过 <code>return this.ttl &lt; System.currentTimeMillis();</code> 的形式来进行比较，ttl 的含义，在👆的代码中我们已经介绍过了，之后通过 <code>return this.softTtl &lt; System.currentTimeMillis();</code>的方式来判断实体是否需要刷新，softTtl的值我们同样已经介绍过了，如果不需要刷新，那么我们就可以直接使用缓存，不然的话就需要向服务器验证缓存的有效性。那么如何通知服务器来进行验证呢，接下来我们看看执行请求的时候，在 <strong>BasicNetwork # performRequest()</strong> 中调用 HttpStack 执行请求执行，会调用 <code>addCacheHeaders(headers, request.getCacheEntry());</code> 方法，用来附加请求头部信息，我们看看该方法内部的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</div><div class="line"><span class="comment">// If there's no cache entry, we're done.</span></div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</div><div class="line">        headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (entry.lastModified &gt; <span class="number">0</span>) &#123;</div><div class="line">        Date refTime = <span class="keyword">new</span> Date(entry.lastModified);</div><div class="line">        headers.put(<span class="string">"If-Modified-Since"</span>,DateUtils.formatDate(refTime));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结合我们上面对请求头的介绍，大家很容易明白这段代码的意思，如果资源没有发生改变，就会返回 304 响应码，告诉我们可以使用之前的缓存，对缓存的分析就到这里。</p>
<h3 id="2-Byte-缓存"><a href="#2-Byte-缓存" class="headerlink" title="2.Byte[] 缓存"></a>2.Byte[] 缓存</h3><p>再次看一下下面这段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Some responses such as 204s do not have content.  We must check.</span></div><div class="line"><span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</div><div class="line">    responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Add 0 byte response as a way of honestly representing a</span></div><div class="line">    <span class="comment">// no-content request.</span></div><div class="line">    responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码位于 BasicNetwork 的 performRequest() 方法中，用于将返回的 HttpEntity 对象转化为 byte[] 对象，这个字节数组最后将用于被转化为 T 类型的对象，也就是请求期望的对象，我们之所以没有直接返回 HttpEntity 对象，而把它解析成 byte[] 就是为之后 Request 的子类进行解析提供便利。<br>接下来，我们看一下用于转换数据的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException, ServerError &#123;</div><div class="line">    PoolingByteArrayOutputStream bytes =</div><div class="line">     <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</div><div class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        InputStream in = entity.getContent();</div><div class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</div><div class="line">        &#125;</div><div class="line">        buffer = mPool.getBuf(<span class="number">1024</span>);</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        <span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">            bytes.write(buffer, <span class="number">0</span>, count);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bytes.toByteArray();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Close the InputStream and release the resources by "consuming the content".</span></div><div class="line">            entity.consumeContent();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="comment">// This can happen if there was an exception above that left the entity in</span></div><div class="line">            <span class="comment">// an invalid state.</span></div><div class="line">            VolleyLog.v(<span class="string">"Error occurred when calling consumingContent"</span>);</div><div class="line">        &#125;</div><div class="line">        mPool.returnBuf(buffer);</div><div class="line">        bytes.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中有两种类型对象我们需要注意，一个是 <code>PoolingByteArrayOutputStream</code> 对象 bytes，另一个是 <code>ByteArrayPool</code> 对象 mPool。我们先说一下没有这两个对象之前的转化方式，首先我们从 HttpEntity 打开是一个输入流，然后构建一个缓冲字节数组 buffer，不断的将输入流的数据写入 buffer 中，在通过 <strong>ByteArrayOutputStream</strong> 不断的将 buffer 中的数据输入到 ByteArrayOutputStream 中的 buf 字节数组中，如果 buf 的大小不够，将会 new 出新的 byte[] 对象，赋值给 buf</p>
<p>在这个过程中，byte[] 对象被不断的创建和销毁，内存不断的分配和回收，如果处理不断可能会造成内存泄漏，消耗了系统资源，Volley 通过 <code>ByteArrayPool</code> 和 <code>PoolingByteArrayOutputStream</code> 来解决这个问题,先看一下 ByteArrayPool 的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayPool</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersByLastUse = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">byte</span>[]&gt;();<span class="comment">//按照使用顺序排列的Buffer缓存</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersBySize = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(<span class="number">64</span>);<span class="comment">//按照 byte[]大小排列的Buffer缓存</span></div><div class="line"></div><div class="line">    <span class="comment">/** 当前缓存池中缓存的总大小 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentSize = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 缓存池上限，达到这个限制之后，最近最长时间未使用的 byte[]       * 将被丢弃</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mSizeLimit;</div><div class="line"></div><div class="line">    <span class="comment">/** 通过 buffer 的大小进行比较 */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;<span class="keyword">byte</span>[]&gt; BUF_COMPARATOR = <span class="keyword">new</span> Comparator&lt;<span class="keyword">byte</span>[]&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">byte</span>[] lhs, <span class="keyword">byte</span>[] rhs)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> lhs.length - rhs.length;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteArrayPool</span><span class="params">(<span class="keyword">int</span> sizeLimit)</span> </span>&#123;</div><div class="line">        mSizeLimit = sizeLimit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从缓存池中获取所需的 byte[]，如果没有大小合适的 byte[]，将新new一个 byte[] 对象</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] getBuf(<span class="keyword">int</span> len) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class="line">            <span class="keyword">byte</span>[] buf = mBuffersBySize.get(i);</div><div class="line">            <span class="keyword">if</span> (buf.length &gt;= len) &#123;</div><div class="line">                mCurrentSize -= buf.length;</div><div class="line">                mBuffersBySize.remove(i);</div><div class="line">                mBuffersByLastUse.remove(buf);</div><div class="line">                <span class="keyword">return</span> buf;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[len];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将使用后的 byte[] 返还给 缓存池</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnBuf</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (buf == <span class="keyword">null</span> || buf.length &gt; mSizeLimit) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mBuffersByLastUse.add(buf);</div><div class="line">        <span class="keyword">int</span> pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</div><div class="line">            pos = -pos - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        mBuffersBySize.add(pos, buf);</div><div class="line">        mCurrentSize += buf.length;</div><div class="line">        trim();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对缓存池数据进行修剪</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (mCurrentSize &gt; mSizeLimit) &#123;</div><div class="line">            <span class="keyword">byte</span>[] buf = mBuffersByLastUse.remove(<span class="number">0</span>);</div><div class="line">            mBuffersBySize.remove(buf);</div><div class="line">            mCurrentSize -= buf.length;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单的来说就是,ByteArrayPool 通过在内存中维护了两组 byte[] 对象，来减少重复创建 byte[] 的次数。当我们需要使用 byte[] 的时候，通过 Pool 来获取一个 byte[],当使用完毕的时候，再将该字节数组返回给 Pool。</p>
<p>在来看看 PoolingByteArrayOutputStream 的代码，他是 ByteArrayOutputStream 的子类,内部使用了 ByteArrayPool 来代替 new Byte[]操作，提高性能:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolingByteArrayOutputStream</span> <span class="keyword">extends</span> <span class="title">ByteArrayOutputStream</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认的 buf 大小</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">256</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteArrayPool mPool;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果写入的数据超出 buf 的大小，将会扩展 buf 的大小，之前通过 new Byte[] 来分配更大的空间，现在通过 ByteArrayPool 提供，避免创建对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PoolingByteArrayOutputStream</span><span class="params">(ByteArrayPool pool)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(pool, DEFAULT_SIZE);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PoolingByteArrayOutputStream</span><span class="params">(ByteArrayPool pool, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        mPool = pool;</div><div class="line">        buf = mPool.getBuf(Math.max(size, DEFAULT_SIZE));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//关闭输出流，将使用的 buf 归还到缓冲池中</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        mPool.returnBuf(buf);</div><div class="line">        buf = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">super</span>.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// GC 的时候调用，我们不能保证高方法的触发时机，所以最好手动调用 close 方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</div><div class="line">        mPool.returnBuf(buf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 扩展 Buf 的大小</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="comment">// 判断 buffer 能否处理更多的byte，不能的话将要扩展 buffer 的大小</span></div><div class="line">        <span class="keyword">if</span> (count + i &lt;= buf.length) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">byte</span>[] newbuf = mPool.getBuf((count + i) * <span class="number">2</span>);</div><div class="line">        System.arraycopy(buf, <span class="number">0</span>, newbuf, <span class="number">0</span>, count);</div><div class="line">        mPool.returnBuf(buf);</div><div class="line">        buf = newbuf;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        expand(len);</div><div class="line">        <span class="keyword">super</span>.write(buffer, offset, len);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> oneByte)</span> </span>&#123;</div><div class="line">        expand(<span class="number">1</span>);</div><div class="line">        <span class="keyword">super</span>.write(oneByte);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内部的操作很简单，在每次写入的时候都会检查 buffer 大小是否合适，是否需要扩展，在输出流结束的时候，我们需要手动显示调用 close 方法，来归还从 ByteArrayPool 中扩展的 byte[]</p>
<h3 id="3-请求重试"><a href="#3-请求重试" class="headerlink" title="3.请求重试"></a>3.请求重试</h3><h4 id="RetryPolicy"><a href="#RetryPolicy" class="headerlink" title="RetryPolicy"></a>RetryPolicy</h4><p><strong>RetryPolicy</strong>  接口，代表着请求重试的行为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> </span>&#123;</div><div class="line">    <span class="comment">//当前超时的时间</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//当前重试的次数</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 准备重试</div><div class="line">     * 当抛出 VolleyError 即意味着停止重试</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我们初始化 Request 的时候，会给 Request 设置一个默认的重试策略 <strong>DefaultRetryPolicy</strong> 下面我们来看看它的代码：</p>
<h4 id="DefaultRetryPolicy"><a href="#DefaultRetryPolicy" class="headerlink" title="DefaultRetryPolicy"></a>DefaultRetryPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRetryPolicy</span> <span class="keyword">implements</span> <span class="title">RetryPolicy</span> </span>&#123;</div><div class="line">    <span class="comment">/** 当前超时毫秒数. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentTimeoutMs;</div><div class="line"></div><div class="line">    <span class="comment">/** 当前重试次数. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentRetryCount;</div><div class="line"></div><div class="line">    <span class="comment">/** 最大重试次数. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mMaxNumRetries;</div><div class="line"></div><div class="line">    <span class="comment">/** 超时乘积因子，用来累计计算超时时间. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mBackoffMultiplier;</div><div class="line"></div><div class="line">    <span class="comment">/** 默认超时时间 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">2500</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 默认重试次数 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 默认超时乘积因子 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_BACKOFF_MULT = <span class="number">1f</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">(<span class="keyword">int</span> initialTimeoutMs, <span class="keyword">int</span> maxNumRetries, <span class="keyword">float</span> backoffMultiplier)</span> </span>&#123;</div><div class="line">        mCurrentTimeoutMs = initialTimeoutMs;</div><div class="line">        mMaxNumRetries = maxNumRetries;</div><div class="line">        mBackoffMultiplier = backoffMultiplier;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回当前超时时间</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mCurrentTimeoutMs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回当前重试次数.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mCurrentRetryCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回超时乘积因子.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getBackoffMultiplier</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBackoffMultiplier;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 为下一次重试计算重试时间</div><div class="line">     * <span class="doctag">@param</span> error 上一次请求的错误.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">        mCurrentRetryCount++;</div><div class="line">        <span class="comment">//累计下一次重试的时间</span></div><div class="line">        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</div><div class="line">        <span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</div><div class="line">            <span class="keyword">throw</span> error;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//抛出参数中传入的错误，就代表停止重试</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断是否允许下一次重试</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认的重试策略也挺简单的，每一次累计超时的时间，然后判断是否到达重试的上限，如果达到上限，就抛出入参的 VolleyError 代表停止重试，那么为什么抛出传入的参数，就可以停止重试了呢，我们继续看看 BasicNetwork 中的 performRequest() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">              <span class="comment">//........省略</span></div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="keyword">int</span> statusCode;</div><div class="line">            <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</div><div class="line">                statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</div><div class="line">            &#125;</div><div class="line">            VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</div><div class="line">            NetworkResponse networkResponse;</div><div class="line">            <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</div><div class="line">                networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,responseHeaders, <span class="keyword">false</span>, SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class="line">                    statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class="line">                    attemptRetryOnException(<span class="string">"auth"</span>,</div><div class="line">                    request, <span class="keyword">new</span> AuthFailureError(networkResponse));</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode &gt;= <span class="number">400</span> &amp;&amp; statusCode &lt;= <span class="number">499</span>) &#123;</div><div class="line">                    <span class="comment">// Don't retry other client errors.</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClientError(networkResponse);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode &gt;= <span class="number">500</span> &amp;&amp; statusCode &lt;= <span class="number">599</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (request.shouldRetryServerErrors()) &#123;</div><div class="line">                        attemptRetryOnException(<span class="string">"server"</span>,</div><div class="line">                        request, <span class="keyword">new</span> ServerError(networkResponse));</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 3xx? No reason to retry.</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                attemptRetryOnException(<span class="string">"network"</span>, request, <span class="keyword">new</span> NetworkError());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这部分的代码我们在上面分析 BasicNetwork 的代码的时候已经介绍过了，当时省略了 <strong>catch</strong> 块中的代码，catch 块中的代码就是用来实现请求重试的。</p>
<p>当捕获到 <strong>SocketTimeoutException</strong> 和 <strong>ConnectTimeoutException</strong> 异常的时候调用 <strong>attemptRetryOnException()</strong> 方法来进行重试，该方法中会调用 <code>retryPolicy.retry(exception);</code>方法，该方法我们已经分析过了，是用来计算请求超时时间，以及是否达到重试上限，如果可以重试，那么该方法执行完，会继续下一次循环，再次发起请求；当达到重试上线，无法进行重试的时候我们会抛出 VolleyError 的实例，在 BasicNetwork#performRequest() 中我们没有捕获 VolleyError 异常，因次会跳出循环，停止重试，该方法执行结束，在外部 NetworkDispatcher 的 run() 方法中捕获了该异常，将异常结果传递到主线程中供回调函数处理。</p>
<ul>
<li><strong>ConnectTimeoutException</strong> 表示请求超时</li>
<li><strong>SocketTimeoutException</strong> 表示响应超时</li>
</ul>
<p>在代码中同样对 <strong>AuthFailureError</strong> 以及服务器异常提供了重试操作。</p>
<h2 id="3-一些总结"><a href="#3-一些总结" class="headerlink" title="3. 一些总结"></a>3. 一些总结</h2><ul>
<li>Volley 可以帮助我们完成请求的自动调度处理，我们只需要将 Request 加入 RequestQueue 就可以了</li>
<li>提供了多个并发线程帮助处理请求，但是不适合大文件下载，因为在响应解析的过程中，会将所有响应的数据保存在内存中</li>
<li>提供了缓存(一定程度上符合 HTTP 语义)</li>
<li>支持请求的优先级，可以方便的取消请求(根据 Tag 或者自定义的过滤规则)</li>
<li>提供了请求重试机制，可以自定义重试机制(简单，方便)</li>
<li>Volley 面向接口编程，采用组合(少用继承)的形式提供功能，可以自定义 Network，HttpStack，Cache 等实现，扩展性很高</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Volley-的使用流程分析&quot;&gt;&lt;a href=&quot;#1-Volley-的使用流程分析&quot; class=&quot;headerlink&quot; title=&quot;1. Volley 的使用流程分析&quot;&gt;&lt;/a&gt;1. Volley 的使用流程分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;官网示例&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个请求队列 &lt;code&gt;RequestQueue&lt;/code&gt;，并启动队列&lt;/li&gt;
&lt;li&gt;创建一个请求 &lt;code&gt;Request&lt;/code&gt; 添加到请求队列中&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-创建-RequestQueue-对象&quot;&gt;&lt;a href=&quot;#1-创建-RequestQueue-对象&quot; class=&quot;headerlink&quot; title=&quot;1. 创建 RequestQueue 对象&quot;&gt;&lt;/a&gt;1. 创建 RequestQueue 对象&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; TextView mTextView = (TextView) findViewById(R.id.text);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实例化一个请求队列&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RequestQueue queue = Volley.newRequestQueue(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String url =&lt;span class=&quot;string&quot;&gt;&quot;http://www.google.com&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建一个期待类型为字符串类型的请求&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;StringRequest stringRequest = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringRequest(Request.Method.GET, url,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Response.Listener&amp;lt;String&amp;gt;() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onResponse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String response)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Display the first 500 characters of the response string.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mTextView.setText(&lt;span class=&quot;string&quot;&gt;&quot;Response is: &quot;&lt;/span&gt;+ response.substring(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Response.ErrorListener() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onErrorResponse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(VolleyError error)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mTextView.setText(&lt;span class=&quot;string&quot;&gt;&quot;That didn&#39;t work!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将请求添加到请求队列中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;queue.add(stringRequest);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码片段的第5行，我们调用 &lt;code&gt;Volley.newRequestQueue(this)&lt;/code&gt; 来创建一个请求队列。&lt;code&gt;Volley&lt;/code&gt; 中提供了两种创建请求队列的方法，&lt;code&gt;newRequestQueue(Context context,HttpStack stack)&lt;/code&gt; 和 &lt;code&gt;newRequestQueue(Context context)&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; RequestQueue &lt;span class=&quot;title&quot;&gt;newRequestQueue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  在此方法内部会调用另一个 newRequestQueue 方法，第二个参数为 null 代表使用默认的 HttpStack 实现&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; newRequestQueue(context, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; RequestQueue &lt;span class=&quot;title&quot;&gt;newRequestQueue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context, HttpStack stack)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 缓存文件目录 data/data/packagename/cache/volley&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    File cacheDir = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(context.getCacheDir(), DEFAULT_CACHE_DIR);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    String userAgent = &lt;span class=&quot;string&quot;&gt;&quot;volley/0&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        String packageName = context.getPackageName();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        userAgent = packageName + &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt; + info.versionCode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (NameNotFoundException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stack == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            stack = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HurlStack();&lt;span class=&quot;comment&quot;&gt;//基于HttpClient&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//基于HttpUrlConnection&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            stack = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HttpClientStack(AndroidHttpClient.newInstance(userAgent));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//利用HttpStack创建一个Network对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Network network = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BasicNetwork(stack);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//创建一个RequestQueue对象，在构造函数中传入缓存对象，网络对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    RequestQueue queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RequestQueue(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DiskBasedCache(cacheDir), network);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//启动队列&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    queue.start();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Volley" scheme="http://realxz.github.io/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Android 内存泄漏分析总结</title>
    <link href="http://realxz.github.io/2017/03/20/Android%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>http://realxz.github.io/2017/03/20/Android 内存泄漏分析总结/</id>
    <published>2017-03-20T14:09:00.000Z</published>
    <updated>2017-05-31T13:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h2><p><a href="https://github.com/realxz/MemoryLeak" target="_blank" rel="external">https://github.com/realxz/MemoryLeak</a><br>GitHub 代码只包含泄漏情况，不包括修改后的代码，大家可以下载下来后，自行修改。</p>
<h2 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h2><p>Android 系统我们的 APP 分配的内存大小是有限的，我现在用的手机小米 4c 为我自己开发的应用 分配的256MB的内存大小，不同的手机型号，不同的 ROM 分配的内存大小不一定一样，这里面所提 到的内存一般是指 Android 手机的 RAM。</p>
<p>RAM 包含寄存器，栈，堆，静态存储区域，常量池。通常我们所说的 Android 内存泄漏中的内存， 指的是其中的堆内存。一般来来说，我们 new 出来的对 象都会存储在堆内存中，这部分的内存由 GC 进行回收管理。</p>
<h2 id="GC-是什么，它如何进行内存管理"><a href="#GC-是什么，它如何进行内存管理" class="headerlink" title="GC 是什么，它如何进行内存管理"></a>GC 是什么，它如何进行内存管理</h2><p>GC 指垃圾回收器 「Garbage Collection」。Java 使用 GC 进行内存回收理，不用我们手动释放内 存，提升了我们的开发效率。那GC回收对象的依据是什么呢 ?简单的说，对于一个对象，若果不存 在从 GC 根节点到该对象的引用链 (从根节点不可到达的 （从根节点不可到达的），那么对于 GC 来说这个对象就是需要被回收的，反之该对象是从根节点可到达的，那么这个对象就不会被 GC 回 收。</p>
<p><strong>根节点</strong>：在 Java 中可以作为根节点的对象有很多，这块内容我理解的不是很到位。我很简单的把它理解为 Android 应用的主线程，存活的子线程，栈中的对象以及静态属性引用的对象。<br><strong>注意</strong>：这里的引用是指强引用，在 Java 当中存在4种引用类型分别是「强引用」、「软引用」、「弱引用」、「虚引用」。如果没有特别指定，我们所说的引用都是指强引用，GC 不会回收具有 强引用的对象。<br><a id="more"></a></p>
<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>我们已经知道了，如果某个对象，从根节点可到达，也就是存在从根节点到该对象的引用链，那么该对象是不会被 GC 回收的。如果说这个对象已经不会再被使用到了，是无用的，我们依然持有他的引用的话，就会造成内存泄漏，例如 一个长期在后台运行的线程持有 Activity 的引用，这个时 候 Activity 执行了 onDestroy 方法，那么这个 Activity 就是从根节点可到达并且无用的对象， 这个 Activity 对象就是泄漏的对象，给这个对象分配的内存将无法被回收。</p>
<h3 id="内存泄漏的影响"><a href="#内存泄漏的影响" class="headerlink" title="内存泄漏的影响"></a>内存泄漏的影响</h3><ul>
<li>内存很宝贵，即使从效率，责任的角度上，我们也应该降低内存的使用，减少内存的浪费。</li>
<li>内存泄漏导致可用内存越来越少，最终导致OOM。</li>
<li>可用内存减少，GC 被触发，虽然 GC 可以帮助我们回收无用内存，但是频繁的触发 GC 也会影响性能，可能造成程序卡顿。</li>
</ul>
<h3 id="如何查找、定位内存泄漏"><a href="#如何查找、定位内存泄漏" class="headerlink" title="如何查找、定位内存泄漏"></a>如何查找、定位内存泄漏</h3><ul>
<li>MAT「Memory AnalysisTools」，网上有很多的使用教程，个人感觉使用较繁琐，需要耐心分析和一定的经验才能定位出内存泄漏。</li>
<li>LeakCanary，Square 公司开源作品，使用方便，可以直接定位到泄漏的对象，并且给出调用链。</li>
</ul>
<p>##内存泄漏事例</p>
<p>###非静态内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package com.example.xiezhen.memoryleak;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">public class InnerThreadActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_inner_thread);</div><div class="line"></div><div class="line">        RunningThread runningThread = new RunningThread();</div><div class="line">        runningThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class RunningThread extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while (true) &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000*5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void closeActivity(View view) &#123;</div><div class="line">        this.finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们运行这段代码的时候，LeakCanary 会帮我们检测出来内存泄漏，如图：</p>
<p><img src="http://static.zybuluo.com/xiezhen/odev0wja0q36wc92pdrmpd22/image_1bbluquud1ndr12k41mdnpbmiv9.png" alt="image_1bbluquud1ndr12k41mdnpbmiv9.png-59.9kB"></p>
<p>在 Java 中，内部类会隐式的持有外部类的引用。我们可以很清楚的看见 RunningThread 对象持有 了 InnerThreadActivity 的引用，由于 RunningThread 线程会一直运行下去，我 finish 掉当前 的 Activity 就会导致 InnerThreadActivity 实例发生泄漏。我们可以采用静态内部类的方式来解 除这种内存泄漏的隐患，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private static class RunningThread extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000 * 5);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：尽量使用静态内部类来替代内部类，同时避免让长期运行的任务（ 线程 ）持有 Activity的引用。</p>
<p>###匿名内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.example.xiezhen.memoryleak;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">public class AnonymousThreadActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_anonymous_thread);</div><div class="line">        Thread anonymousThread = new Thread() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                while (true) &#123;</div><div class="line">                    //do something</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(60 * 1000);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        anonymousThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void closeActivity(View view) &#123;</div><div class="line">        this.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeakCanary 同样会检测出内存泄漏，如图：</p>
<p><img src="http://static.zybuluo.com/xiezhen/ak2lk5h73l0axpcf7kmz8ib5/image_1bbluvkf51um53c04fucmr1g8cm.png" alt="image_1bbluvkf51um53c04fucmr1g8cm.png-69.7kB"></p>
<p>在 Java 中，匿名内部类和非静态内部类一样，都会持有外部类的引用。上面的代码正式由于 Thread 的匿名类持有了 AnonymousThreadActivity 的引用，并且匿名类的运行时间长达 1 分钟， 在这段时间内，我 finish 掉了 Activity 导致了内存泄漏，解决方式和非静态内部类的方法一样，使用静态内部类来代替匿名内部类，这里就不贴代码了。</p>
<p>###Handler 内存泄漏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.example.xiezhen.memoryleak;</div><div class="line"></div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Message;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.TextView;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">public class HandlerActivity extends AppCompatActivity &#123;</div><div class="line">    private TextView tvShowMessage;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler);</div><div class="line">        tvShowMessage = (TextView) findViewById(R.id.tv_show_message);</div><div class="line">        MemoryLeakHandler handler = new MemoryLeakHandler();</div><div class="line">        handler.sendMessageDelayed(Message.obtain(), 1000 * 10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class MemoryLeakHandler extends Handler &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            tvShowMessage.setText(&quot;MemoryLeak&quot;);</div><div class="line">            Toast.makeText(HandlerActivity.this, &quot;memory leak&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void closeActivity(View view) &#123;</div><div class="line">        this.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/xiezhen/ddv0e7hhwbtvf22ev4tkkt6e/image_1bblv16hj148t1bvmjge13jd5if13.png" alt="image_1bblv16hj148t1bvmjge13jd5if13.png-79.1kB"></p>
<p>LeakCanary 为我们展示了内存泄漏的引用链，这段代码泄漏的原因也是因为非静态内部类持有了外部类的引用。图中的引用链涉及到 Android 中的消息机制 「Handler」、「MessageQueue」、 「Looper」。大致叙述一下，我们的 MemoryLeakHandler 因为内部类的关系会持有 HandlerActivity 实例的引用，我们使用 Handler 来发送消息，这个Handler 会被消息中 target 属性引用，这个 Message 会在我们主线程的消息队 列中存活 10 秒钟，在这段时间内，我 finish 掉当前 Activity 就会造成内存泄漏，并且依然会弹出 Toast 尽管我们已经开不见这个  Activity了。</p>
<p>解决方案依然是采用<strong>静态内部类</strong>来替代非静态内部类，并且使用 <strong>WeakReference</strong> 来引用 Activity，如果对象只存在弱引用的话，GC 是会回收这部分内存的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.example.xiezhen.memoryleak;</div><div class="line"></div><div class="line">import android.os.Handler;</div><div class="line">import android.os.Message;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.TextView;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">import java.lang.ref.WeakReference;</div><div class="line"></div><div class="line">public class HandlerActivity extends AppCompatActivity &#123;</div><div class="line">    private TextView tvShowMessage;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler);</div><div class="line">        tvShowMessage = (TextView) findViewById(R.id.tv_show_message);</div><div class="line">        MemoryLeakHandler handler = new MemoryLeakHandler(this);</div><div class="line">        handler.sendMessageDelayed(Message.obtain(), 1000 * 10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class MemoryLeakHandler extends Handler &#123;</div><div class="line">        private WeakReference&lt;HandlerActivity&gt; weakReference;</div><div class="line"></div><div class="line">        public MemoryLeakHandler(HandlerActivity activity) &#123;</div><div class="line">            this.weakReference = new WeakReference&lt;HandlerActivity&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            HandlerActivity activity = weakReference.get();</div><div class="line">            if (activity != null) &#123;</div><div class="line">                activity.tvShowMessage.setText(&quot;MemoryLeak&quot;);</div><div class="line">                Toast.makeText(activity, &quot;memory leak&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void closeActivity(View view) &#123;</div><div class="line">        this.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###单例／静态引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static volatile EventBus defaultInstance;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static EventBus getDefault() &#123;</div><div class="line">    if (defaultInstance == null) &#123;</div><div class="line">        synchronized (EventBus.class) &#123;</div><div class="line">            if (defaultInstance == null) &#123;</div><div class="line">                defaultInstance = new EventBus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package com.example.xiezhen.memoryleak;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">import org.greenrobot.eventbus.EventBus;</div><div class="line">import org.greenrobot.eventbus.Subscribe;</div><div class="line">import org.greenrobot.eventbus.ThreadMode;</div><div class="line"></div><div class="line">public class EventBusActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_event_bus);</div><div class="line">        EventBus.getDefault().register(this);</div><div class="line">        EventBusThread thread=new EventBusThread();</div><div class="line">        thread.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void closeActivity(View view) &#123;</div><div class="line">        this.finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class EventBusThread extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            EventBus.getDefault().post(&quot;eventbus&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.MAIN)</div><div class="line">    public void receiveMessage(String message) &#123;</div><div class="line">        Toast.makeText(this, message, Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EventBus 我相信大家都不陌生，我们一般在使用 EventBus 的时候，都会使用EventBus.getDefault( ) 方法来获取一个 EventBus 单例，这个单例是静态的，全局可访问的。上面的代码我们在获取 EventBus 单例后调用 register 方法，将 EventBusActivity 注册到 EventBus 中，这个时候 EventBus 就会持有 Activity 的引用，由于单例是静态的，生命周期和整个 App 生命周期 一致，如果我们不调用 unRegister 方法的话，EventBusActivity 实例就会泄漏。上述代码中，我特意没有去调用 unRegister 方法，我们来看看 LeakCanary 的结果：</p>
<p><img src="http://static.zybuluo.com/xiezhen/58kb04ti3bgd5ttfgxcajx9b/image_1bblv9o5chuh4m6i6m1l8t1mnc1g.png" alt="image_1bblv9o5chuh4m6i6m1l8t1mnc1g.png-88kB"></p>
<ul>
<li>不要让我们的对象被静态属性所引用，这很容易造成内存泄漏。</li>
<li>一般来说我们在使用注册方法的时候，library 都会提供相对应的解除注册方法，不要忘了调用！</li>
</ul>
<p>###Activity Context &amp; Application Context<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">package com.example.xiezhen.memoryleak;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.content.pm.PackageInfo;</div><div class="line"></div><div class="line">/**</div><div class="line">* Created by xiezhen on 2017/3/16.</div><div class="line">*/</div><div class="line"></div><div class="line">public class CommonHelper &#123;</div><div class="line">    private Context context;</div><div class="line">    private static CommonHelper commonHelper = null;</div><div class="line"></div><div class="line">    private CommonHelper(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static CommonHelper getCommonHelper(Context context) &#123;</div><div class="line">        if (commonHelper == null) &#123;</div><div class="line">            commonHelper = new CommonHelper(context);</div><div class="line">        &#125;</div><div class="line">        return commonHelper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getVersionCode() &#123;</div><div class="line">        PackageInfo packInfo = getPackageInfo(context);</div><div class="line">        if (packInfo != null) &#123;</div><div class="line">            return packInfo.versionCode;</div><div class="line">        &#125; else &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public  String getVersionName() &#123;</div><div class="line">        PackageInfo packInfo = getPackageInfo(context);</div><div class="line">        if (packInfo != null) &#123;</div><div class="line">            return packInfo.versionName;</div><div class="line">        &#125; else &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private PackageInfo getPackageInfo(Context context) &#123;</div><div class="line">        try &#123;</div><div class="line">            return context.getPackageManager().getPackageInfo(context.getPackageName(), 0);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">package com.example.xiezhen.memoryleak;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.TextView;</div><div class="line"></div><div class="line">public class ContextActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView tvVersionName;</div><div class="line">    private TextView tvVersionCode;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_context);</div><div class="line">        tvVersionName = (TextView) findViewById(R.id.tv_version_name);</div><div class="line">        tvVersionCode = (TextView) findViewById(R.id.tv_version_code);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        setVersionCode(CommonHelper.getCommonHelper(this).getVersionCode());</div><div class="line">        setVersionName(CommonHelper.getCommonHelper(this).getVersionName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void setVersionName(String versionName) &#123;</div><div class="line">        tvVersionName.setText(versionName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void setVersionCode(int versionCode) &#123;</div><div class="line">        tvVersionCode.setText(String.valueOf(versionCode));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void closeActivity(View view) &#123;</div><div class="line">        this.finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我写了一个工具类，来获取 App 的 Version Code 和 Version Name，这段代码同样会导致内存泄漏，下面是 LeakCanary 的泄露图。</p>
<p><img src="http://static.zybuluo.com/xiezhen/kvxq3e0vkmd7n5fxd8g4zlgf/image_1bblvctrqieh39h9asvsm9p91t.png" alt="image_1bblvctrqieh39h9asvsm9p91t.png-60.1kB"></p>
<p>发现泄露了一个 Context 实例，在调用 CommonHelper 中的方法时候的时候，我们将 ContextActivity 作为一个 Context 对象传递了进去，Context 对象的引用被长期持有导致内存泄漏。处理这种泄漏的方法很简单，使用 Application Context 来代替 Activity Context 即可，Application Context 在整个 App 生命周期内适用。</p>
<p>##结论<br>一般来说，内存泄漏都是因为<strong>泄漏对象</strong>的引用被传递到该对象的<strong>范围之外</strong>，或者说内存泄漏是因为持有对象的<strong>长期引用</strong>，导致对象无法被 GC 回收。为了避免这种情况，我们可以选择在对象生命周期结束的时候，解除绑定，将引用置为空，或者使用弱引用。</p>
<ol>
<li><strong>由于 Context 导致内存泄漏</strong>。使用 Application Context 代替 Activity Context，避免长期持有 Context 的引用，引用应该和 Context 自身的生命周期保持一致。</li>
<li><strong>由于非静态内部类、匿名内部类导致内存泄</strong>。它们会隐式的持有外部类的引用，一不小心长期持有该引用就会导致内存泄漏，使用静态内部类来代替它们。</li>
<li><strong>Handler 导致内存泄漏</strong>。原因和第二点一样，同样使用静态内部类的实现方式，同时对需要引用的对象/资源采用弱引用的方式。</li>
<li><strong>EventBus导致内存泄漏</strong>。EventBus 的单例特性，会长期持有注册对象的引用，一定要在对象生命周期结束的时候，接触注册，释放引用。同样对于系统提供的一些成对出现的方法，我们也需要成对的调用，例如 BroadcastReceiver 的 registerReceiver( ) 方法和 unRegisterReceiver( ) 方法。</li>
<li><strong>线程导致内存泄漏</strong>。我们经常会执行一些长期运行的任务，避免在这些任务中持有 Activity 对象的引用，如果持有了引用的话，我们应该在对象生命周期结束的时候，释放引用。</li>
</ol>
<p>##参考链接</p>
<ul>
<li><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html</a></li>
<li><a href="http://www.androiddesignpatterns.com/2013/04/activitys-threads-memory-leaks.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2013/04/activitys-threads-memory-leaks.html</a></li>
<li><a href="https://android-developers.googleblog.com/2009/01/avoiding-memory-leaks.html" target="_blank" rel="external">https://android-developers.googleblog.com/2009/01/avoiding-memory-leaks.html</a></li>
<li><a href="https://medium.com/freenet-engineering/memory-leaks-in-android-identify-treat-and-avoid-d0b1233acc8#.45ldsvqll" target="_blank" rel="external">https://medium.com/freenet-engineering/memory-leaks-in-android-identify-treat-and-avoid-d0b1233acc8#.45ldsvqll</a></li>
<li><a href="http://droidyue.com/blog/2016/11/23/memory-leaks-in-android/index.html" target="_blank" rel="external">http://droidyue.com/blog/2016/11/23/memory-leaks-in-android/index.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitHub地址&quot;&gt;&lt;a href=&quot;#GitHub地址&quot; class=&quot;headerlink&quot; title=&quot;GitHub地址&quot;&gt;&lt;/a&gt;GitHub地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/realxz/MemoryLeak&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/realxz/MemoryLeak&lt;/a&gt;&lt;br&gt;GitHub 代码只包含泄漏情况，不包括修改后的代码，大家可以下载下来后，自行修改。&lt;/p&gt;
&lt;h2 id=&quot;什么是内存&quot;&gt;&lt;a href=&quot;#什么是内存&quot; class=&quot;headerlink&quot; title=&quot;什么是内存&quot;&gt;&lt;/a&gt;什么是内存&lt;/h2&gt;&lt;p&gt;Android 系统我们的 APP 分配的内存大小是有限的，我现在用的手机小米 4c 为我自己开发的应用 分配的256MB的内存大小，不同的手机型号，不同的 ROM 分配的内存大小不一定一样，这里面所提 到的内存一般是指 Android 手机的 RAM。&lt;/p&gt;
&lt;p&gt;RAM 包含寄存器，栈，堆，静态存储区域，常量池。通常我们所说的 Android 内存泄漏中的内存， 指的是其中的堆内存。一般来来说，我们 new 出来的对 象都会存储在堆内存中，这部分的内存由 GC 进行回收管理。&lt;/p&gt;
&lt;h2 id=&quot;GC-是什么，它如何进行内存管理&quot;&gt;&lt;a href=&quot;#GC-是什么，它如何进行内存管理&quot; class=&quot;headerlink&quot; title=&quot;GC 是什么，它如何进行内存管理&quot;&gt;&lt;/a&gt;GC 是什么，它如何进行内存管理&lt;/h2&gt;&lt;p&gt;GC 指垃圾回收器 「Garbage Collection」。Java 使用 GC 进行内存回收理，不用我们手动释放内 存，提升了我们的开发效率。那GC回收对象的依据是什么呢 ?简单的说，对于一个对象，若果不存 在从 GC 根节点到该对象的引用链 (从根节点不可到达的 （从根节点不可到达的），那么对于 GC 来说这个对象就是需要被回收的，反之该对象是从根节点可到达的，那么这个对象就不会被 GC 回 收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根节点&lt;/strong&gt;：在 Java 中可以作为根节点的对象有很多，这块内容我理解的不是很到位。我很简单的把它理解为 Android 应用的主线程，存活的子线程，栈中的对象以及静态属性引用的对象。&lt;br&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里的引用是指强引用，在 Java 当中存在4种引用类型分别是「强引用」、「软引用」、「弱引用」、「虚引用」。如果没有特别指定，我们所说的引用都是指强引用，GC 不会回收具有 强引用的对象。&lt;br&gt;
    
    </summary>
    
    
      <category term="内存泄漏" scheme="http://realxz.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="OOM" scheme="http://realxz.github.io/tags/OOM/"/>
    
  </entry>
  
</feed>
