<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="I can go,I can do.">
<meta property="og:type" content="website">
<meta property="og:title" content="Echo">
<meta property="og:url" content="http://realxz.github.io/index.html">
<meta property="og:site_name" content="Echo">
<meta property="og:description" content="I can go,I can do.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Echo">
<meta name="twitter:description" content="I can go,I can do.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://realxz.github.io/"/>





  <title>Echo</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ae009c4e520d5f8877994f78ceab9fa7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Echo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Take it.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://realxz.github.io/2017/05/31/Volley 源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oqt31j82i.bkt.clouddn.com/test.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/Volley 源码分析/" itemprop="url">Volley 源码分析（不包含图片加载的内容）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T17:00:21+08:00">
                2017-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Volley-的使用流程分析"><a href="#1-Volley-的使用流程分析" class="headerlink" title="1. Volley 的使用流程分析"></a>1. Volley 的使用流程分析</h2><blockquote>
<p>官网示例</p>
<ol>
<li>创建一个请求队列 <code>RequestQueue</code>，并启动队列</li>
<li>创建一个请求 <code>Request</code> 添加到请求队列中</li>
</ol>
</blockquote>
<h3 id="1-创建-RequestQueue-对象"><a href="#1-创建-RequestQueue-对象" class="headerlink" title="1. 创建 RequestQueue 对象"></a>1. 创建 RequestQueue 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> TextView mTextView = (TextView) findViewById(R.id.text);</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 实例化一个请求队列</span></div><div class="line">RequestQueue queue = Volley.newRequestQueue(<span class="keyword">this</span>);</div><div class="line">String url =<span class="string">"http://www.google.com"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个期待类型为字符串类型的请求</span></div><div class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</div><div class="line">            <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">        <span class="comment">// Display the first 500 characters of the response string.</span></div><div class="line">        mTextView.setText(<span class="string">"Response is: "</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">        mTextView.setText(<span class="string">"That didn't work!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 将请求添加到请求队列中</span></div><div class="line">queue.add(stringRequest);</div></pre></td></tr></table></figure>
<p>上面代码片段的第5行，我们调用 <code>Volley.newRequestQueue(this)</code> 来创建一个请求队列。<code>Volley</code> 中提供了两种创建请求队列的方法，<code>newRequestQueue(Context context,HttpStack stack)</code> 和 <code>newRequestQueue(Context context)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"><span class="comment">//  在此方法内部会调用另一个 newRequestQueue 方法，第二个参数为 null 代表使用默认的 HttpStack 实现</span></div><div class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</div><div class="line">    <span class="comment">// 缓存文件目录 data/data/packagename/cache/volley</span></div><div class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line"></div><div class="line">    String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String packageName = context.getPackageName();</div><div class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">        userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">            stack = <span class="keyword">new</span> HurlStack();<span class="comment">//基于HttpClient</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//基于HttpUrlConnection</span></div><div class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//利用HttpStack创建一个Network对象</span></div><div class="line">    Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line"></div><div class="line">    <span class="comment">//创建一个RequestQueue对象，在构造函数中传入缓存对象，网络对象</span></div><div class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">    <span class="comment">//启动队列</span></div><div class="line">    queue.start();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面代码片段中的第2行可以看见，<code>Volley</code> 调用 <code>getCacheDir()</code> 方法来获取缓存目录，<code>Volley</code> 中的缓存文件会存储在 <strong>/data/data/packagename/cache</strong> 目录下面，并不是存储在 SD 卡中的。</p>
<p>从12~18的代码可以看见，<strong>Volley</strong> 当中有对 <code>HttpStack</code> 的默认实现，<code>HttpStack</code> 是真正用来执行请求的接口 ，根据版本号的不同，实例化不同的对象，在  <strong>Android2.3</strong> 版本之前采用基于 <strong>HttpClient</strong> 实现的 <strong>HttpClientStack</strong> 对象，不然则采用基于 <strong>HttpUrlConnection</strong> 实现的 <strong>HUrlStack</strong>。</p>
<p>之后我们通过 <code>HttpStack</code> 构建了一个 <code>Network</code> 对象，它会调用 <code>HttpStack#performRequest()</code> 方法来执行请求，并且将请求的结果转化成 <code>NetworkResponse</code> 对象，<strong>NetworkResponse</strong> 类封装了响应的<strong>响应码</strong>，<strong>响应体</strong>，<strong>响应头</strong>等数据。</p>
<p>接着我们会将之前构建的缓存目录以及网络对象传入 <code>RequestQueue(Cache cache, Network network)</code> 的构造函数中，构造一个 <strong>RequestQueue</strong> 对象，然后调用队列的 <code>start()</code>方法来启动队列，其实就是启动队列中的两种线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//启动队列中所有的调度线程.</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    stop();  <span class="comment">// 确保停止所有当前正在运行的调度线程</span></div><div class="line">    <span class="comment">// 创建缓存调度线程，并启动它，用来处理缓存队列中的请求</span></div><div class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue,mNetworkQueue,mCache,mDelivery);</div><div class="line">    mCacheDispatcher.start();</div><div class="line"></div><div class="line">    <span class="comment">// 创建一组网络调度线程，并启动它们，用来处理网络队列中的请求，默认线程数量为4，也可以通过RequestQueue的构造函数指定线程数量。</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue,mNetwork,mCache, mDelivery);</div><div class="line">        mDispatchers[i] = networkDispatcher;</div><div class="line">        networkDispatcher.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <strong>start()</strong> 方法中，主要是启动了两种线程分别是 <code>CacheDispatcher</code> 和 <code>NetworkDispatcher</code>，它们都是线程类，顾名思义 <strong>CacheDispatcher</strong> 线程会处理缓存队列中请求，<strong>NetworkDispatcher</strong> 处理网络队列中的请求，由此可见在我们调用 <strong>Volley</strong> 的公开方法创建请求队列的时候，其实就是开启了两种线程在等待着处理我们添加的请求。</p>
<p>###2. 添加请求 add(Request)</p>
<p>之前我们已经创建了 RequestQueue 对象，现在我们只需要构建一个 <strong>Request</strong> 对象，并将它加入到请求队列中即可。下面我们来看看 <code>add(Request&lt;T&gt; request)</code> 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将请求加入到当前请求队列当中，毋庸置疑的我们需要将所有的请求集合在一个队列中，方便我们做统一操作，例如：取消单个请求或者取消具有相同标记的请求...</span></div><div class="line">    request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">        mCurrentRequests.add(request);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 给请求设置顺序.</span></div><div class="line">    request.setSequence(getSequenceNumber());</div><div class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 如果请求是不能够被缓存的，直接将该请求加入网络队列中.</span></div><div class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">        mNetworkQueue.add(request);</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果有相同的请求正在被处理，就将请求加入对应请求的等待队列中去.等到相同的正在执行的请求处理完毕的时候会调用 finish()方法，然后将这些等待队列中的请求全部加入缓存队列中去，让缓存线程来处理</span></div><div class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">        String cacheKey = request.getCacheKey();</div><div class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            <span class="comment">// 有相同请求在处理，加入等待队列.</span></div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            stagedRequests.add(request);</div><div class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);&#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 向mWaitingRequests中插入一个当前请求的空队列，表明当前请求正在被处理</span></div><div class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">            mCacheQueue.add(request);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<center><img src="http://static.zybuluo.com/xiezhen/eg4o9tcjsieaaom3yjro7kcr/add.png" alt="add.png-53.6kB"></center><br><center><strong>RequestQueue#add(Request)</strong> 方法的调用流程</center>

<p>###3. 处理请求 Cache/NetworkDispatcher</p>
<p>请求被加入缓存请求队列或者是网络请求队列，在后台我们的缓存处理线程，网络处理线程，一直在运行着等待着请求的到来。我们先来看看 <strong>CacheDispatcher</strong> 线程是如何处理的:</p>
<p><strong>CacheDispatcher</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(</span></span></div><div class="line">    BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class="line">    Cache cache, ResponseDelivery delivery) &#123;</div><div class="line">    mCacheQueue = cacheQueue;</div><div class="line">    mNetworkQueue = networkQueue;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 <strong>CacheDispatcher</strong> 的构造函数，可以看见该对象内部持有<strong>缓存队列</strong>，<strong>网络队列</strong>，<strong>缓存对象</strong>，<strong>响应投递对象</strong>的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"></div><div class="line">    <span class="comment">// 初始化缓存，将缓存目录下的所有缓存文件的摘要信息加载到内存中.</span></div><div class="line">    mCache.initialize();</div><div class="line"></div><div class="line">    <span class="comment">//无线循环，意味着线程启动之后会一直运行</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 从缓存队列中取出一个请求，如果没有请求则一直等待</span></div><div class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 如果当前请求已经取消，那就停止处理它</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 尝试取出缓存实体对象</span></div><div class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                <span class="comment">// 没有缓存，将当前请求加入网络请求队列，让NetworkDispatcher进行处理.</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 如果缓存实体过期，任然将当前请求加入网络请求队列，让NetworkDispatcher进行处理.</span></div><div class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">                mNetworkQueue.put(request);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 将缓存实体解析成NetworkResponse对象.</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">            <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                <span class="comment">// 缓存依旧新鲜，投递响应.</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//缓存已经不新鲜了，我们可以进行响应投递，然后将请求加入网络队列中去，进行新鲜度验证，如果响应码为 304，代表缓存新鲜可以继续使用，不用刷新响应结果</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line"></div><div class="line">                <span class="comment">// 标记当前响应为中间响应，如果经过服务器验证缓存不新鲜了，那么随后将有第二条响应到来.这意味着当前请求并没有完成，只是暂时显示缓存的数据，等到服务器验证缓存的新鲜度之后才会将请求标记为完成</span></div><div class="line">                response.intermediate = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 将响应投递给用户，然后加入网络请求队列中去.</span></div><div class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            mNetworkQueue.put(request);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            <span class="comment">// Not much we can do about this.</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码的注释中基本上可以理清 CacheDispatcher 的工作流程，下面附上流程图<br><img src="http://static.zybuluo.com/xiezhen/azn7u8x7sh22q1dn8zq2oewq/%E7%BC%93%E5%AD%98run%E6%96%B9%E6%B3%95%20.png" alt="缓存run方法 .png-95.6kB"></p>
<center><strong>CacheDispatcher#run() 方法内部流程</strong></center>

<p><strong>NetworkDispatcher</strong><br>在 CacheDispatcher 当中我们会把一些不符合条件的请求加入网络请求队列中，下面我们来看看在 <strong>NetworkDispatcher</strong> 的 <strong>run()</strong> 方法中是怎么来处理这些请求的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span></span></div><div class="line">    Network network, Cache cache,ResponseDelivery delivery) &#123;</div><div class="line">    mQueue = queue;</div><div class="line">    mNetwork = network;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是 <strong>NetworkDispatcher</strong> 的构造函数，可以看见该对象内部持有<strong>网络队列</strong>，<strong>缓存对象</strong>，<strong>响应投递对象</strong>,<strong>Network对象</strong>的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">        Request&lt;?&gt; request;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 从网络队列中取出一个请求，没有请求则一直等待.</span></div><div class="line">            request = mQueue.take();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        <span class="comment">// We may have been interrupted because it was time to quit.</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 如果请求被取消的话，就结束当前请求，不再执行</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            addTrafficStatsTag(request);</div><div class="line"></div><div class="line">            <span class="comment">// 执行网络请求.</span></div><div class="line">            NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">            request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line">            <span class="comment">// 如果响应码为304，并且我们已经传递了一次响应,不需要再传递一次验证的响应，意味着本次请求处理完成。也就是说该请求的缓存是新鲜的，我们直接使用就可以了。</span></div><div class="line">            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 在工作线程中想响应数据解析成我们需要的Response对象，之所以在工作线程进行数据解析，是为了避免一些耗时操作造成主线程的卡顿.</span></div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">            request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line">            <span class="comment">// 如果允许，则将响应数据写入缓存，这里的缓存是需要服务器支持的，这点我们接下来再说</span></div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></div><div class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 传递响应数据.</span></div><div class="line">            request.markDelivered();</div><div class="line">            mDelivery.postResponse(request, response);</div><div class="line">        &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">            parseAndDeliverNetworkError(request, volleyError);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">            VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</div><div class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">            mDelivery.postError(request, volleyError);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码当中的第29行，我们调用 <strong>Network</strong> 对象的 <code>performRequest(Request&lt;?&gt; request)</code> 方法来执行网络请求，并且返回我们需要的 <strong>NetworkResponse</strong> 对象。如果是304响应，并且我们已经传递过一次响应，就不需要在传递新的解析数据，不然我们将数据解析成 Reponse 对象，并传递给主线程进行回到处理，如果该请求允许被缓存，就将该请求的结果写入缓存中去，这就是 Networkdispatcher 的工作流程。以下是 NetworkDispatcher 的流程图:</p>
<center><img src="http://static.zybuluo.com/xiezhen/ndyibftufjge6wxj6hltrxr0/%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8Brun%E6%96%B9%E6%B3%95.png" alt="网络处理线程run方法.png-73.9kB"></center><br><center><strong>NetworkDispatcher的run() 方法</strong></center>

<h3 id="4-执行请求-performRequest"><a href="#4-执行请求-performRequest" class="headerlink" title="4. 执行请求 performRequest"></a>4. 执行请求 performRequest</h3><p>在上面 <strong>NetworkDispatcher</strong> 的代码中第29行，会通过 <code>Network</code> 的 <code>performRequest</code> 方法来进行网络请求:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 执行指定的请求.</div><div class="line">    * <span class="doctag">@param</span> request 被处理的请求</div><div class="line">    * <span class="doctag">@return</span> 一个 NetworkResponse 对象，包含响应的数据，头部以及响应码等数据</div><div class="line">    * <span class="doctag">@throws</span> VolleyError on errors</div><div class="line">    */</div><div class="line">    <span class="function">NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Network 是一个接口，它的内部只有这一个方法，在 Volley 中我们最终调用的是它的实现类，BasicNetwork 的 performRequest() 方法，方法如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();<span class="comment">//请求开始的时间</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</div><div class="line">        Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 收集头部</span></div><div class="line">            Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">            <span class="comment">//对于addCacheHeaders这个方法，我们也会在缓存的部分进行介绍</span></div><div class="line">            addCacheHeaders(headers, request.getCacheEntry());<span class="comment">//附加请求头部,用来验证缓存数据？</span></div><div class="line">            httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">            StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">            <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</div><div class="line"></div><div class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">            <span class="comment">// 验证缓存的新鲜度.</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">                <span class="comment">//请求的资源没有修改，意思可以使用缓存中的数据</span></div><div class="line">                Cache.Entry entry = request.getCacheEntry();</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</div><div class="line">                    responseHeaders, <span class="keyword">true</span>,SystemClock.elapsedRealtime() -requestStart);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// A HTTP 304 response does not have all header fields. We</span></div><div class="line">                <span class="comment">// have to use the header fields from the cache entry plus</span></div><div class="line">                <span class="comment">// the new ones from the response.</span></div><div class="line">                <span class="comment">// http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</span></div><div class="line">                entry.responseHeaders.putAll(responseHeaders);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                            entry.responseHeaders, <span class="keyword">true</span>,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></div><div class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</div><div class="line">                responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Add 0 byte response as a way of honestly representing a</span></div><div class="line">                <span class="comment">// no-content request.</span></div><div class="line">                responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// if the request is slow, log it. 请求持续时间</span></div><div class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">            logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//一条真正的网络响应</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,SystemClock.elapsedRealtime() - requestStart);</div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            <span class="comment">//......这部分代码是用来进行请求重试的，我们随后在做解析</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面代码的第12行，又会调用 <code>HttpStack</code> 对象的 <code>performRequest()</code> 方法去执行网络请求，在 <strong>HttpStack</strong> 中才真正进行网络请求，HttpStack 对象在我们一开始调用 Volley.newRequestQueue() 的方法时候初始化的，默认情况下，如果系统版本在 Android2.3 之前就会创建 HttpClientStack，之后就会创建 HUrlStack 对象，同样我们也可以实现自己的 HttpStack对象，通过 Volley 的重载方法 newRequestQueue(Context,HttpStack) 将我们自定义的 HttpStack 传入即可。</p>
<p>在代码的18行，我们会进行新鲜度验证，如果是304响应那么我们会直接利用缓存实体的数据。之后会将响应的数据组装成一个 NetworkResponse 对象返回。<br>在回到之前 <strong>NetworkDispatcher</strong> 的代码中，当我们获得这个 NetworkResponse 对象之后，如果是304响应那我们的请求处理结束，不然的话就会调用 <code>Request#parseNetworkResponse(NetworkResponse)</code> 方法将 NetworkResponse 对象解析成我们需要的 Response 对象，这是一个抽象方法，由子类具体实现来解析成期望的响应类型，此方法在工作线程调用。如果该请求可以被缓存，就会将响应实体写入缓存，标记请求被投递，然后调用 <code>ResponseDelivery</code> 对象的 <code>postResponse()</code> 方法来将解析的结果投递到主线程中，然后进行回调处理。</p>
<h3 id="5-响应传递、回调-postResponse"><a href="#5-响应传递、回调-postResponse" class="headerlink" title="5.响应传递、回调 postResponse"></a>5.响应传递、回调 postResponse</h3><p>响应结果投递接口，主要负责将响应的结果/错误，投递到主线程中，供回调函数处理:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseDelivery</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传递从网络或者缓存中解析的Response对象.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传递从网络或者缓存中解析的Response对象.提供一个Runnable对象，会在传递之后执行</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传递给定请求的Error</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的内部实现类为 <code>ExecutorDelivery</code>，让我们来看看 <strong>ExecutorDelivery</strong> 中的具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">        mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">                handler.post(command);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们会在 postResponse 方法中调用 mResponsePoster 对象的 execute 方法，紧接着通过 handler 对象发送一个消息，这个消息是 <code>ResponseDeliveryRunnable</code> 对象，它是 Runnable 的实现类，并且这个 Runnable 对象会在主线程被执行，为什么呢？这是因为 handler 是在 ExecutorDelivery 初始化的时候作为参数传递出来的，我们可以看一下该构造函数调用的时机:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</div><div class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看见我们使用主线的 Looper 在构建一个 Handler对象，所以由该 Handler 对象发送的消息，都会在主线程被执行，不熟悉 Handler 机制的可以看下这篇文章 <a href="http://blog.csdn.net/xiezhenaini/article/details/49644853" target="_blank" rel="external">Android消息机制</a>。</p>
<p>接着我们看看这个 <strong>ResponseDeliveryRunnable</strong> 类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//......省略</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// If this request has canceled, finish it and don't deliver.</span></div><div class="line">        <span class="comment">/** 如果请求已经取消的话，就不用在投递了*/</span></div><div class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Deliver a normal response or error, depending.</span></div><div class="line">        <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">            mRequest.deliverResponse(mResponse.result);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mRequest.deliverError(mResponse.error);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class="line">        <span class="comment">// and the request can be finished.</span></div><div class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mRequest.finish(<span class="string">"done"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></div><div class="line">        <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                mRunnable.run();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个 Runnable 会在主线程执行，然后将响应结果传递给请求的回调函数。在代码中的15，17行就是我们的回调函数，每一个请求的响应结果，不论是成功或者是失败，都会传递到这两个方法中，第15行的 <code>deliverResponse</code> 方法也是一个抽象方法，由子类实现，参照 Volley 提供的 StringRequest 可以看见，在这个方法中，我们最终将期望的对象传递给了 <code>Response</code> 中的 <code>onResponse()</code> 方法中，可以看 <strong>创建 RequestQueue 对象</strong> 这一段落的第一段代码中的12行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</div><div class="line">            <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">        <span class="comment">// Display the first 500 characters of the response string.</span></div><div class="line">        mTextView.setText(<span class="string">"Response is: "</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">        mTextView.setText(<span class="string">"That didn't work!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>请求的结果最终就会被传递这 <code>onResponse</code>,<code>onErrorResponse</code> 中。在这里贴一张 Volley 内部的 Response 转换流程图:</p>
<center><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/response-process-flow-chart.png" alt="Response 处理流程图"></center><br><center>图片取自<a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">codeKK Volley 源码分析</a></center><br>### 6.请求完成 Request#finish(String)<br>在执行完我们的回调函数之后，会调用 Request 中的 finish() 方法标记请求完成，然后会将我们的请求从请求队列中移除,以下代码展示了两处调用 finish() 的地方:<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">    mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    mRequest.finish(<span class="string">"done"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>他们的区别是，第一段代码的 Response 是从网络返回的数据，而第二段代码是代表我们之前传递了需要验证缓存新鲜度的缓存实体，经验证后缓存新鲜，标记请求完成，大家可以查看一下 Response 的 intermediate 属性被赋值的时机就明白了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Request中的finish()会调用 RequestQueue中的finish()方法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</div><div class="line">         mRequestQueue.finish(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// RequestQueue#finish(Request)</span></div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">//从当前的请求队列中移除该请求</span></div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">        mCurrentRequests.remove(request);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用该请求设置的回调函数</span></div><div class="line">    <span class="keyword">synchronized</span> (mFinishedListeners) &#123;</div><div class="line">        <span class="keyword">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class="line">        listener.onRequestFinished(request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                            waitingRequests.size(), cacheKey);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// Process all queued up requests. They won't be considered as in flight, but</span></div><div class="line">                <span class="comment">// that's not a problem as the cache has been primed by 'request'.</span></div><div class="line">                mCacheQueue.addAll(waitingRequests);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>在移除已经完成的请求之后，如果该请求是可以缓存的，并且存在着等待该请求的等待队列，就将队列中的所有请求加入缓存队列（mCacheQueue) 中去，让缓存线程接着处理。<br>### 7.补充一点—取消请求<br><br> - 可以调用 Request 的 cancel() 方法来标记请求取消，这样我们的回调函数永远不会被调用<br> - 可以调用 RequstQueue 的 cancelAll(Object) 的方法来批量取消被打上 Object 标记的请求<br> - 可以调用 RequstQueue 的 cancelAll(RequestFilter) 的方法，按照自定义的过滤方法来取消符合过滤条件的请求<br><br>###8. 抽象的处理流程图<br><center><img src="http://static.zybuluo.com/xiezhen/28yjzliwl05211ach572puow/%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="抽象的流程图.png-43.3kB"></center>

<p>通过 CacheDispatcher 和 NetworkDispatcher 两种线程不断的从 RequestQueue 中取出请求来处理，然后将获取的数据在子线程解析成我们需要的结果，通过 ResponseDelivery 的 postResponse 方法将结果投递到主线程中去，触发回调。</p>
<h2 id="2-请求缓存和重试机制"><a href="#2-请求缓存和重试机制" class="headerlink" title="2.请求缓存和重试机制"></a>2.请求缓存和重试机制</h2><p>再此之前我们先看一下 <code>Request</code> 类中的一些重要属性和方法:<br><strong>Request<t></t></strong><br>所有请求的抽象类，T 类型代表请求期望的类型，也是响应最终被解析成的类型。支持 <code>Get</code>,<code>Post</code>,<code>Put</code>,<code>Delete</code>,<code>Options</code>,<code>Trace</code>,<code>Head</code>,<code>Patch</code> 共8种请求，提供 <code>Low</code>,<code>Normal</code>,<code>Hight</code>,<code>Imediate</code> 4种优先级。下面会挑出一些比较重要的字段和方法进行讲解:</p>
<ul>
<li><strong>mShouldCache</strong>，用于标识请求是否允许缓存，缓存需要客户端和服务器的支持，这个字段仅仅代表客户端是否支持缓存</li>
<li><strong>mShouldRetryServerErrors</strong>，默认值为 false，代表在服务器返回响应码在 500~599的范围内的话(服务器错误)，不进行请求重试</li>
<li><strong>mCacheEntry</strong>，该请求的缓存实体，在 CacheDispatcher 处理 CacheQueue 中请求的时候，会判断该请求之前是否有缓存存在，如果存在的话将缓存实体赋值给该字段。用于在服务器返回 304 响应的时候构建 <strong>NetworkResponse</strong> 对象</li>
<li><strong>mResponseDelivered</strong>，代表该请求的响应结果已经被投递到主线程，只有在响应被传递给主线程的时候标记为 true，它的作用同样是用来验证缓存一致性</li>
<li><strong>abstract protected Response<t> parseNetworkResponse(NetworkResponse response)</t></strong>;抽象方法，将请求返回的结果解析成请求期望的类型，具体的解析方式需要子类实现</li>
<li><p><strong>abstract protected void deliverResponse(T response);</strong>抽象方法，也同样需要子类自行实现，将解析后的结果传递给请求的回调函数<br>之前我们有提到过要实现请求缓存需要客户端和服务器端共同的支持才行。</p>
<h3 id="1-请求缓存"><a href="#1-请求缓存" class="headerlink" title="1.请求缓存"></a>1.请求缓存</h3><p>之前我们说过，缓存机制是需要客户端和服务器端共同支持的。从客户端的角度来说：需要实现 Http 缓存相关的语义；从服务器的角度来说：需要允许请求的资源被缓存；我们先来看一些有关于 Http 请求头和响应头的概念:</p>
<h4 id="HTTP-响应头"><a href="#HTTP-响应头" class="headerlink" title="HTTP 响应头"></a><strong>HTTP 响应头</strong></h4><p><strong>Cache-Control</strong>:指明当前资源的有效期，用来控制从缓存中取数据，还是需要将请求发送到服务器进行验证，重新取回数据,该头部有以下几个值：</p>
</li>
<li><p>no-cache:使用缓存前必须先向服务器确认其有效性</p>
</li>
<li>no-store:不缓存响应的任何内容，相同的请求都会发送给服务器</li>
<li>max-age:缓存有效性的最长时间</li>
<li>must-revalidate:可缓存，但是使用的时候必需向源服务器验证</li>
<li>proxy-revalidate:要求中间缓存服务器对缓存的有效性进行确认</li>
<li>stale-while-revalidate：在这段时间内，允许先使用缓存，但需要向服务器验证缓存的有效性</li>
</ul>
<p><strong>Expires</strong>:资源失效的日期，如果和 max-age 同时存在，以 max-age 时间为准<br><strong>ETag</strong>:可将资源以字符串形式做唯一性标识的方式，服务器会为每份资源分配对应的 Etag 值<br><strong>Last-Modified</strong>:资源最终被修改的时间</p>
<h4 id="HTTP-请求头"><a href="#HTTP-请求头" class="headerlink" title="HTTP 请求头"></a><strong>HTTP 请求头</strong></h4><p><strong>If-None-Match</strong>：如果上一次响应的的响应头部中带有 ETag 响应头，再次请求的时候会将 ETag 的值作为 If-None-Match 请求头的值，当 If-None-Match 的值与请求资源的 Etag 不一致时，服务器会处理该请求，该字段用来获取最新的资源<br><strong>If-Modified-Since</strong>：如果上一次响应的响应头部中带有 Last-Modified 响应头，那么再次请求的时候会将 Last-Modified 的值作为 If-Modified-Since 请求头的值，在If-Modified-Since 字段指定的之后，资源发生了更新，服务器会接受该请求，否则返回 304 响应</p>
<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>Cache接口中的内部类，代表着缓存实体</p>
<ul>
<li><strong>data</strong>，这是一个字节数组，其实也就是我们响应的 Content 部分</li>
<li><strong>etag</strong>，用来验证缓存一致性的标记</li>
<li><strong>serverDate</strong>，数据从服务器返回的时间</li>
<li><strong>lastModified</strong>，访问的服务器资源上次被修改的时间</li>
<li><strong>ttl</strong>，数据的过期时间，在(softTtl-ttl)这段时间内我们可以使用缓存，但是必须向服务器验证缓存的有效性</li>
<li><strong>softTtl</strong>，数据的新鲜时间，缓存再次之前一直有效</li>
<li><strong>responseHeaders</strong>，响应头部</li>
<li><strong>boolean isExpired()</strong>，判断是否过期，ttl代表的时间小于当前时间就意味着过期了</li>
<li><strong>boolean refreshNeeded()</strong>，顾名思义，当softTtl代表的时间小于当前时间，就代表数据不新鲜了，需要刷新数据</li>
</ul>
<p>下面我们来看看 Volley 中是怎么利用这些头部信息来对响应结果进行缓存处理的：<br>在 NetworkDispatcher 的 run() 方法中有这样一样代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">    request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想要缓存响应结果需要满足两个条件，第一条该请求允许缓存，我们创建的每一条请求都是默认支持缓存的；第二条就是响应对象中的缓存实体不为空。那么我们需要看一下缓存实体是在什么时候被创建的，在执行上述的 if 语句判断之前会执行这么一句代码 <code>Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</code> 通过parseNetworkResponse 方法将 NetworkResponse 对象转化为 Response 对象，<strong>parseNetworkResponse</strong> 方法是一个抽象方法，我们看一下 StringRequest 中是如何重写该方法的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</div><div class="line">    String parsed;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</div><div class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">        parsed = <span class="keyword">new</span> String(response.data);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码的最后一行，我们会发现 Response 中的 cacheEntry 字段的值来自于 <code>HttpHeaderParser.parseCacheHeaders(response)</code>方法的返回值，下面我们来看看该方法的内部实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">    <span class="comment">//提取响应头部信息</span></div><div class="line">    Map&lt;String, String&gt; headers = response.headers;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> serverDate = <span class="number">0</span>;<span class="comment">//资源返回时间</span></div><div class="line">    <span class="keyword">long</span> lastModified = <span class="number">0</span>;<span class="comment">//资源上一次被修改的时间</span></div><div class="line">    <span class="keyword">long</span> serverExpires = <span class="number">0</span>;<span class="comment">//资源的有效时间，以maxAge为主</span></div><div class="line">    <span class="keyword">long</span> softExpire = <span class="number">0</span>;<span class="comment">//资源的新鲜时间，如果在该时间内，发起相同的请求，那么可以允许使用缓存的信息，不需要将请求发送给服务器。</span></div><div class="line">    <span class="keyword">long</span> finalExpire = <span class="number">0</span>;<span class="comment">//缓存过期时间，在该时间之后的请求，都将发送给服务器，无法使用缓存。</span></div><div class="line">    <span class="keyword">long</span> maxAge = <span class="number">0</span>;<span class="comment">//资源的有效时间，</span></div><div class="line">    <span class="comment">//在 staleWhileRevalidate 时间内，我们可以先用缓存数据展示给用户，在向服务器验证缓存的有效性</span></div><div class="line">    <span class="keyword">long</span> staleWhileRevalidate = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> hasCacheControl = <span class="keyword">false</span>;<span class="comment">//代表是否有 Cache-Control 头部</span></div><div class="line">    <span class="keyword">boolean</span> mustRevalidate = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    String serverEtag = <span class="keyword">null</span>;<span class="comment">//资源在服务器中的标识</span></div><div class="line">    String headerValue;</div><div class="line"></div><div class="line">    headerValue = headers.get(<span class="string">"Date"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        serverDate = parseDateAsEpoch(headerValue);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取 Cache-Contral 头部的相关信息</span></div><div class="line">    headerValue = headers.get(<span class="string">"Cache-Control"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        hasCacheControl = <span class="keyword">true</span>;</div><div class="line">        String[] tokens = headerValue.split(<span class="string">","</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</div><div class="line">            String token = tokens[i].trim();</div><div class="line">            <span class="keyword">if</span> (token.equals(<span class="string">"no-cache"</span>) || token.equals(<span class="string">"no-store"</span>)) &#123;</div><div class="line">            <span class="comment">//如果出现了 no-cache,no-store指令，代表服务器不允许缓存响应，返回的 entry 对象为空</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"max-age="</span>)) &#123;</div><div class="line">            <span class="comment">//如果出现了 max-age指令，那么服务器允许缓存该响应，并且给出响应的过期时间</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    maxAge = Long.parseLong(token.substring(<span class="number">8</span>));</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"stale-while-revalidate="</span>)) &#123;</div><div class="line">            <span class="comment">//这段时间处于新鲜时间和过期时间之间，在这段时间内发起的请求，都可以利用之前的缓存信息，但是需要将请求发送给服务器做验证，如果是304 响应，则请求结束，不然将重新传递响应结果。</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    staleWhileRevalidate = Long.parseLong(token.substring(<span class="number">23</span>));</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"must-revalidate"</span>) || token.equals(<span class="string">"proxy-revalidate"</span>)) &#123;</div><div class="line">            <span class="comment">//代表不区分新鲜时间与过期时间，到了max-age指定的时间之后，请求都将发送给服务器用来验证缓存的有效性。</span></div><div class="line">                mustRevalidate = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    headerValue = headers.get(<span class="string">"Expires"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        serverExpires = parseDateAsEpoch(headerValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    headerValue = headers.get(<span class="string">"Last-Modified"</span>);</div><div class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</div><div class="line">        lastModified = parseDateAsEpoch(headerValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    serverEtag = headers.get(<span class="string">"ETag"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 在 Cache-Control 和 Expires 头部都存在的情况下，以Cache-Control为准</span></div><div class="line">    <span class="keyword">if</span> (hasCacheControl) &#123;</div><div class="line">        softExpire = now + maxAge * <span class="number">1000</span>;</div><div class="line">        finalExpire = mustRevalidate</div><div class="line">                    ? softExpire</div><div class="line">                    : softExpire + staleWhileRevalidate * <span class="number">1000</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</div><div class="line">    <span class="comment">// Default semantic for Expire header in HTTP specification is softExpire.</span></div><div class="line">        softExpire = now + (serverExpires - serverDate);</div><div class="line">        finalExpire = softExpire;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Cache.Entry entry = <span class="keyword">new</span> Cache.Entry();</div><div class="line">    entry.data = response.data;</div><div class="line">    entry.etag = serverEtag;</div><div class="line">    entry.softTtl = softExpire;</div><div class="line">    entry.ttl = finalExpire;</div><div class="line">    entry.serverDate = serverDate;</div><div class="line">    entry.lastModified = lastModified;</div><div class="line">    entry.responseHeaders = headers;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个静态工具方法，用于提取响应头部的信息，来构建一个 Cache.Entry 类型的缓存对象，针对该方法的分析都已经写在注释当中。现在我们已经了解了将响应转化为缓存的部分，下面我们来看看，Volley 是如何使用缓存的,在上面我们介绍 <strong>CacheDispatcher</strong> 工作流程的时候已经大致看过了处理缓存请求的过程，下面我再针对缓存的部分具体分析一下，下面是 CacheDispatcher run() 方法的部分代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line"><span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">    mNetworkQueue.put(request);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">    request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">    request.setCacheEntry(entry);</div><div class="line">    mNetworkQueue.put(request);</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line">Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">            <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line"><span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">    mDelivery.postResponse(request, response);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    request.setCacheEntry(entry);</div><div class="line">    response.intermediate = <span class="keyword">true</span>;</div><div class="line">    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            mNetworkQueue.put(request);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先从缓存中取出缓存实体，然后通过 <code>isExpired()</code> 判断该缓存有无过期，内部是通过 <code>return this.ttl &lt; System.currentTimeMillis();</code> 的形式来进行比较，ttl 的含义，在👆的代码中我们已经介绍过了，之后通过 <code>return this.softTtl &lt; System.currentTimeMillis();</code>的方式来判断实体是否需要刷新，softTtl的值我们同样已经介绍过了，如果不需要刷新，那么我们就可以直接使用缓存，不然的话就需要向服务器验证缓存的有效性。那么如何通知服务器来进行验证呢，接下来我们看看执行请求的时候，在 <strong>BasicNetwork # performRequest()</strong> 中调用 HttpStack 执行请求执行，会调用 <code>addCacheHeaders(headers, request.getCacheEntry());</code> 方法，用来附加请求头部信息，我们看看该方法内部的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</div><div class="line"><span class="comment">// If there's no cache entry, we're done.</span></div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</div><div class="line">        headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (entry.lastModified &gt; <span class="number">0</span>) &#123;</div><div class="line">        Date refTime = <span class="keyword">new</span> Date(entry.lastModified);</div><div class="line">        headers.put(<span class="string">"If-Modified-Since"</span>,DateUtils.formatDate(refTime));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结合我们上面对请求头的介绍，大家很容易明白这段代码的意思，如果资源没有发生改变，就会返回 304 响应码，告诉我们可以使用之前的缓存，对缓存的分析就到这里。</p>
<h3 id="2-请求重试"><a href="#2-请求重试" class="headerlink" title="2.请求重试"></a>2.请求重试</h3><h4 id="RetryPolicy"><a href="#RetryPolicy" class="headerlink" title="RetryPolicy"></a>RetryPolicy</h4><p><strong>RetryPolicy</strong>  接口，代表着请求重试的行为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> </span>&#123;</div><div class="line">    <span class="comment">//当前超时的时间</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//当前重试的次数</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 准备重试</div><div class="line">     * 当抛出 VolleyError 即意味着停止重试</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我们初始化 Request 的时候，会给 Request 设置一个默认的重试策略 <strong>DefaultRetryPolicy</strong> 下面我们来看看它的代码：</p>
<h4 id="DefaultRetryPolicy"><a href="#DefaultRetryPolicy" class="headerlink" title="DefaultRetryPolicy"></a>DefaultRetryPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRetryPolicy</span> <span class="keyword">implements</span> <span class="title">RetryPolicy</span> </span>&#123;</div><div class="line">    <span class="comment">/** 当前超时毫秒数. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentTimeoutMs;</div><div class="line"></div><div class="line">    <span class="comment">/** 当前重试次数. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentRetryCount;</div><div class="line"></div><div class="line">    <span class="comment">/** 最大重试次数. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mMaxNumRetries;</div><div class="line"></div><div class="line">    <span class="comment">/** 超时乘积因子，用来累计计算超时时间. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mBackoffMultiplier;</div><div class="line"></div><div class="line">    <span class="comment">/** 默认超时时间 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">2500</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 默认重试次数 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 默认超时乘积因子 */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_BACKOFF_MULT = <span class="number">1f</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">(<span class="keyword">int</span> initialTimeoutMs, <span class="keyword">int</span> maxNumRetries, <span class="keyword">float</span> backoffMultiplier)</span> </span>&#123;</div><div class="line">        mCurrentTimeoutMs = initialTimeoutMs;</div><div class="line">        mMaxNumRetries = maxNumRetries;</div><div class="line">        mBackoffMultiplier = backoffMultiplier;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回当前超时时间</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mCurrentTimeoutMs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回当前重试次数.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mCurrentRetryCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回超时乘积因子.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getBackoffMultiplier</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBackoffMultiplier;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 为下一次重试计算重试时间</div><div class="line">     * <span class="doctag">@param</span> error 上一次请求的错误.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">        mCurrentRetryCount++;</div><div class="line">        <span class="comment">//累计下一次重试的时间</span></div><div class="line">        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</div><div class="line">        <span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</div><div class="line">            <span class="keyword">throw</span> error;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//抛出参数中传入的错误，就代表停止重试</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断是否允许下一次重试</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认的重试策略也挺简单的，每一次累计超时的时间，然后判断是否到达重试的上限，如果达到上限，就抛出入参的 VolleyError 代表停止重试，那么为什么抛出传入的参数，就可以停止重试了呢，我们继续看看 BasicNetwork 中的 performRequest() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">              <span class="comment">//........省略</span></div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="keyword">int</span> statusCode;</div><div class="line">            <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</div><div class="line">                statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</div><div class="line">            &#125;</div><div class="line">            VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</div><div class="line">            NetworkResponse networkResponse;</div><div class="line">            <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</div><div class="line">                networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,responseHeaders, <span class="keyword">false</span>, SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class="line">                    statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class="line">                    attemptRetryOnException(<span class="string">"auth"</span>,</div><div class="line">                    request, <span class="keyword">new</span> AuthFailureError(networkResponse));</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode &gt;= <span class="number">400</span> &amp;&amp; statusCode &lt;= <span class="number">499</span>) &#123;</div><div class="line">                    <span class="comment">// Don't retry other client errors.</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClientError(networkResponse);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode &gt;= <span class="number">500</span> &amp;&amp; statusCode &lt;= <span class="number">599</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (request.shouldRetryServerErrors()) &#123;</div><div class="line">                        attemptRetryOnException(<span class="string">"server"</span>,</div><div class="line">                        request, <span class="keyword">new</span> ServerError(networkResponse));</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 3xx? No reason to retry.</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                attemptRetryOnException(<span class="string">"network"</span>, request, <span class="keyword">new</span> NetworkError());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这部分的代码我们在上面分析 BasicNetwork 的代码的时候已经介绍过了，当时省略了 <strong>catch</strong> 块中的代码，catch 块中的代码就是用来实现请求重试的。</p>
<p>当捕获到 <strong>SocketTimeoutException</strong> 和 <strong>ConnectTimeoutException</strong> 异常的时候调用 <strong>attemptRetryOnException()</strong> 方法来进行重试，该方法中会调用 <code>retryPolicy.retry(exception);</code>方法，该方法我们已经分析过了，是用来计算请求超时时间，以及是否达到重试上限，如果可以重试，那么该方法执行完，会继续下一次循环，再次发起请求；当达到重试上线，无法进行重试的时候我们会抛出 VolleyError 的实例，在 BasicNetwork#performRequest() 中我们没有捕获 VolleyError 异常，因次会跳出循环，停止重试，该方法执行结束，在外部 NetworkDispatcher 的 run() 方法中捕获了该异常，将异常结果传递到主线程中供回调函数处理。</p>
<ul>
<li><strong>ConnectTimeoutException</strong> 表示请求超时</li>
<li><strong>SocketTimeoutException</strong> 表示响应超时</li>
</ul>
<p>在代码中同样对 <strong>AuthFailureError</strong> 以及服务器异常提供了重试操作。</p>
<h2 id="3-一些总结"><a href="#3-一些总结" class="headerlink" title="3. 一些总结"></a>3. 一些总结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://realxz.github.io/2017/05/31/test-my-site/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oqt31j82i.bkt.clouddn.com/test.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/test-my-site/" itemprop="url">test_my_site</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T14:00:41+08:00">
                2017-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://realxz.github.io/2017/05/31/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oqt31j82i.bkt.clouddn.com/test.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T13:56:49+08:00">
                2017-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oqt31j82i.bkt.clouddn.com/test.jpg"
               alt="Echo" />
          <p class="site-author-name" itemprop="name">Echo</p>
           
              <p class="site-description motion-element" itemprop="description">I can go,I can do.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/realxz" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005055856904460/home?from=page_100505&mod=TAB&is_hot=1#place" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Echo</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
